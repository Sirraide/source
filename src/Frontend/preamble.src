__srcc_internal__

proc ** (in $T base, copy $T exp) __srcc_builtin_op__ -> T = match {
    // Anything to the power of 0 is 1.
    exp == 0: 1;

    // Raising 0 to any non-negative power is 0. Raising 0 to a negative
    // power is an error since that is just division by zero.
    base == 0: {
        assert exp >= 0, "attempting to raise 0 to a negative power";
        0;
    }

    // Raising to a negative power.
    //
    // For any number that isn't -1 or 1, this results in a fraction in
    // the interval (-1, 1), which for integers is just 0.
    exp < 0: match base {
        -1: if exp & 1 != 0 then -1; else 1;
        1: 1;
        _: 0;
    }

    // Perform the exponentiation.
    _: {
        var v = base;
        while exp != 1 {
            v *= base;
            exp -= 1;
        }

        // We're done once 'exp' is 1.
        v;
    }
}

proc **= (inout $T base, in $T exp) __srcc_builtin_op__ -> T^ {
    base = base ** exp;
    return &base;
}

// FIXME: Should be '$T[]'
proc == (in $T a, in T b) __srcc_builtin_op__ -> bool {
    if a.size != b.size return false;
    for v1, v2 in a, b if v1 != v2 return false;
    return true;
}

// TODO: Make this 'inline'.
proc __srcc_swap (inout $T a, inout $T b) {
    T tmp = a;
    a = b;
    b = tmp;
}

/// Helpers for formatting assert messages.
///
/// FIXME: These should be in the runtime once we support importing
/// modules during constant-evaluation.
// struct __src_assert_msg_buf {
//     i8^ data;
//     int size;
//     int capacity;
// }

// proc __src_append_int (inout __src_assert_msg_buf into, copy int value) nomangle {
//     // 0 is a special case.
//     if value == 0 then {
//         __src_append_str(into, '0');
//         return;
//     }

//     // For everything else, we need a tempoary buffer.
//     i8[int.bits] tmp;
//     int bits_used = 0;

//     // Remember whether this was negative.
//     bool negative = value < 0;
//     if negative then value = -value;

//     // Append the digits.
//     while value != 0 {
//         tmp[bits_used] = (value % 10) as i8 + '0'[0];
//         value /= 10;
//         bits_used++;
//     }

//     // If the value was negative, add a minus sign.
//     if negative then __src_append_str(into, '-');

//     // Reverse the digits.
//     for i in 0..<bits_used/2 {
//         int j = bits_used - i - 1;
//         tmp[i] >< tmp[j];
//     }

//     // And append them.
//     __src_append_str(into, (&tmp, bits_used));
// }

// proc __src_append_str (inout __src_assert_msg_buf into, i8[] str) nomangle {
//     if into.size + str.size >= into.capacity return;
//     __srcc_memcpy(__srcc_ptradd(into.data, into.size), str.data, str.size);
//     into.size += str.size;
// }
