__srcc_internal__

// TODO: Move all of these into a '__srcc_builtin' module once we support
// exporting templates from

// ============================================================================
//  Builtin Exponentiation Operator(s)
// ============================================================================
proc ** (in $T base, copy $T exp) __srcc_builtin_op__ -> T = match {
    // Anything to the power of 0 is 1.
    exp == 0: 1;

    // Raising 0 to any non-negative power is 0. Raising 0 to a negative
    // power is an error since that is just division by zero.
    base == 0: {
        assert exp >= 0, "attempting to raise 0 to a negative power";
        0;
    }

    // Raising to a negative power.
    //
    // For any number that isn't -1 or 1, this results in a fraction in
    // the interval (-1, 1), which for integers is just 0.
    exp < 0: match base {
        -1: if exp & 1 != 0 then -1 else 1;
        1: 1;
        _: 0;
    }

    // Perform the exponentiation.
    _: {
        var v = base;
        while exp != 1 {
            v *= base;
            exp -= 1;
        }

        // We're done once 'exp' is 1.
        v;
    }
}

proc **= (inout $T base, in $T exp) inline __srcc_builtin_op__ -> T^ {
    base = base ** exp;
    return &base;
}

// ============================================================================
//  Builtin Equality Operators
// ============================================================================
proc == (in $T a, in T b) __srcc_builtin_op__ -> bool where T.is_slice {
    if a.size != b.size return false;
    for v1, v2 in a, b if v1 != v2 return false;
    return true;
}

proc == (in $T a, in T b) inline __srcc_builtin_op__ -> bool where T.is_array {
    // Just delegate to the slice implementation.
    return T.elem[](a) == T.elem[](b);
}

proc == (in $T a, in T b) __srcc_builtin_op__ -> bool where T.is_optional {
    if a == nil or b == nil return a == nil and b == nil;
    return a as T.elem == b as T.elem;
}

// ============================================================================
//  Builtin Array Arithmetic Operators
// ============================================================================
// TODO: Add the remaining arithmetic operators.
// TODO: Use macros to define these.
proc + (in $T a, in T b) __srcc_builtin_op__ -> T where T.is_array {
    T res;
    for enum i, v1, v2 in a, b do res[i] = v1 + v2;
    return res;
}

// ============================================================================
//  Swap Implementation
// ============================================================================
proc __srcc_swap (inout $T a, inout $T b) inline __srcc_no_mnum__ {
    T tmp = a;
    a = b;
    b = tmp;
}
