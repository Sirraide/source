module;

#include <base/Assert.hh>
#include <llvm/IR/IRBuilder.h>
#include <llvm/IR/Module.h>

export module srcc.codegen;
import srcc.ast;
import srcc;

export namespace srcc {
class CodeGen;
}

class srcc::CodeGen : DiagsProducer<std::nullptr_t> {
    struct Mangler;
    friend DiagsProducer;

    TranslationUnit& M;
    std::unique_ptr<llvm::Module> llvm;
    StringMap<llvm::Constant*> strings;
    DenseMap<LocalDecl*, llvm::AllocaInst*> locals;
    DenseMap<ProcDecl*, std::string> mangled_names;
    llvm::IRBuilder<> builder;
    llvm::Function* curr_func{};

    llvm::IntegerType* const IntTy;
    llvm::IntegerType* const I1Ty;
    llvm::IntegerType* const I8Ty;
    llvm::PointerType* const PtrTy;
    llvm::IntegerType* const FFIIntTy;
    llvm::StructType* const SliceTy;
    llvm::StructType* const ClosureTy;
    llvm::Type* const VoidTy;

    CodeGen(TranslationUnit& M);

public:
    static auto Emit(TranslationUnit& M) -> std::unique_ptr<llvm::Module> {
        CodeGen CG{M};
        CG.Emit();
        return std::move(CG.llvm);
    }

    /// Get the diagnostics engine.
    auto diags() const -> DiagnosticsEngine& { return M.context().diags(); }

private:
    auto ConvertCC(CallingConvention cc) -> llvm::CallingConv::ID;
    auto ConvertLinkage(Linkage lnk) -> llvm::GlobalValue::LinkageTypes;

    template <typename Ty = llvm::Type>
    auto ConvertType(Type ty) -> Ty* { return cast<Ty>(ConvertTypeImpl(ty)); }
    auto ConvertTypeImpl(Type ty) -> llvm::Type*;
    auto ConvertTypeForMem(Type ty) -> llvm::Type*;
    auto ConvertProcType(ProcType* ty) -> llvm::FunctionType*;

    template <typename... Args>
    void Diag(Diagnostic::Level lvl, Location where, std::format_string<Args...> fmt, Args&&... args) {
        M.context().diags().diag(lvl, where, fmt, std::forward<Args>(args)...);
    }

    auto DeclareProcedure(ProcDecl* proc) -> llvm::FunctionCallee;

    void Emit();
    auto Emit(Stmt* stmt) -> llvm::Value*;
#define AST_DECL_LEAF(Class)
#define AST_STMT_LEAF(Class) auto Emit##Class(Class* stmt) -> llvm::Value*;
#include "srcc/AST.inc"
    auto EmitClosure(ProcDecl* proc) -> llvm::Constant*;
    void EmitProcedure(ProcDecl* proc);
    auto EmitValue(const eval::Value& val) -> llvm::Constant*;

    void EmitLocal(LocalDecl* decl);

    /// Same as CreateGlobalStringPtr(), but is interned.
    auto GetString(StringRef s) -> llvm::Constant*;

    auto MakeInt(const APInt& val) -> llvm::ConstantInt*;
    auto MangledName(ProcDecl* proc) -> StringRef;
};
