module;

#include <srcc/Macros.hh>
#include <llvm/Support/Casting.h>
#include <llvm/Support/PointerLikeTypeTraits.h>

export module srcc.ast:type;
import srcc;
import :enums;

export namespace srcc {
class Module;
#define AST_TYPE(node) class node;
#include "srcc/AST.inc"

template <typename Wrapped>
class TypeWrapper;
using Ty = TypeWrapper<Type>;


/// Casting.
template <typename To, typename From> auto cast(srcc::TypeWrapper<From> from) -> srcc::TypeWrapper<To>;
template <typename To, typename From> auto dyn_cast(srcc::TypeWrapper<From> from) -> std::optional<srcc::TypeWrapper<To>>;
template <typename To, typename From> auto isa(srcc::TypeWrapper<From> from) -> bool;
} // namespace srcc

/// Type of an expression or declaration.
///
/// Types are immutable, so itâ€™s fine to pass them by non-`const`
/// reference or pointer in most cases.
class srcc::Type {
    SRCC_IMMOVABLE(Type);

    template <typename Wrapped>
    friend class TypeWrapper;

public:
    enum struct Kind : u8 {
#define AST_TYPE_LEAF(node) node,
#include "srcc/AST.inc"

    };

    const Kind type_kind;
    Dependence dep = Dependence::None;

protected:
    explicit Type(Kind kind, Dependence dep = Dependence::None) : type_kind{kind}, dep{dep} {}

public:
    // Only allow allocating these in the module.
    void* operator new(usz) = SRCC_DELETED("Use `new (mod) { ... }` instead");
    void* operator new(usz size, Module& mod);

    /// Get the dependence of this type.
    auto dependence() const -> Dependence { return dep; }

    /// Print a type to stdout.
    void dump(bool use_colour = false) const;

    /// Get the kind of this type.
    auto kind() const -> Kind { return type_kind; }

    /// Check if this type is the builtin 'void' type.
    bool is_void() const;

private:
    auto print(bool use_colour) const -> std::string;
    auto print_impl(utils::Colours C) const -> std::string;
};

/// A type together with qualifiers.
template <typename Wrapped = srcc::Type>
class srcc::TypeWrapper {
public:
    using WrappedType = Wrapped;

private:
    WrappedType* pointer;

public:
    TypeWrapper(WrappedType* t) : pointer{t} {}

    template <std::derived_from<WrappedType> Derived>
    TypeWrapper(Derived* derived) : pointer{derived} {}

    template <std::derived_from<WrappedType> Derived>
    TypeWrapper(TypeWrapper<Derived> derived) : pointer{derived.ptr()} {}

    /// Get this as an opaque pointer.
    auto as_opaque_ptr() const -> void* { return pointer; }

    /// Print a type.
    auto print(bool use_colour) const -> std::string {
        return pointer->print(use_colour);
    }

    /// Get the type pointer.
    auto ptr() const -> WrappedType* { return pointer; }

    /// Access the type pointer.
    auto operator->() const -> WrappedType* { return pointer; }

    /// Check if two types are equal.
    auto operator==(TypeWrapper other) const -> bool { return pointer == other.pointer; }

    /// Construct a `TypeWrapper` from an opaque pointer.
    static auto FromOpaquePointer(void* ptr) -> TypeWrapper {
        return TypeWrapper{static_cast<WrappedType*>(ptr)};
    }
};

class srcc::SingleElementTypeBase : public Type {
    Ty element_type;

protected:
    SingleElementTypeBase(Kind kind, Ty elem) : Type{kind}, element_type{elem} {}

public:
    /// Get the element type of this type, e.g. `int` for `int[3]`.
    auto elem() const -> Ty { return element_type; }

    static bool classof(const Type* e) {
        return e->kind() >= Kind::ArrayType and e->kind() <= Kind::ReferenceType;
    }
};

class srcc::ArrayType final : public SingleElementTypeBase
    , public FoldingSetNode {
    i64 elems;

    ArrayType(
        Ty elem,
        i64 size
    ) : SingleElementTypeBase{Kind::ArrayType, elem}, elems{size} {
        Assert(size >= 0, "Negative array size?");
    }

public:
    /// Get the number of elements in this array.
    auto dimension() const -> i64 { return elems; }

    void Profile(FoldingSetNodeID& ID) const { Profile(ID, elem(), elems); }
    static auto Get(Module& mod, Ty elem, i64 size) -> ArrayType*;
    static void Profile(FoldingSetNodeID& ID, Ty elem, i64 size);
    static bool classof(const Type* e) { return e->kind() == Kind::ArrayType; }
};

class srcc::BuiltinType final : public Type {
    // The module creates all instances of these.
    friend Module;
    const BuiltinKind b_kind;

    explicit BuiltinType(BuiltinKind kind) : Type{Kind::BuiltinType}, b_kind{kind} {}

public:
    /// Get the kind of this builtin type.
    auto builtin_kind() const -> BuiltinKind { return b_kind; }

    static auto Get(Module& mod, BuiltinKind kind) = SRCC_DELETED("Use Module.VoidTy and friends instead");
    static bool classof(const Type* e) { return e->kind() == Kind::BuiltinType; }
};

class srcc::IntType final : public Type
    , public FoldingSetNode {
    i64 bits;

    explicit IntType(i64 bit_width) : Type{Kind::IntType}, bits{bit_width} {
        Assert(bits >= 0, "Negative bit width?");
    }

public:
    /// Get the bit width of this integer type.
    auto bit_width() const -> Size { return Size::Bits(bits); }

    void Profile(FoldingSetNodeID& ID) const { Profile(ID, bits); }
    static auto Get(Module& mod, i64 bit_width) -> IntType*;
    static auto Get(Module& mod, Size size) -> IntType* { return Get(mod, i64(size.bits())); }
    static void Profile(FoldingSetNodeID& ID, i64 bit_width);
    static bool classof(const Type* e) { return e->kind() == Kind::IntType; }
};

class srcc::ReferenceType final : public SingleElementTypeBase
    , public FoldingSetNode {
    explicit ReferenceType(Ty elem) : SingleElementTypeBase{Kind::ReferenceType, elem} {}

public:
    void Profile(FoldingSetNodeID& ID) const { Profile(ID, elem()); }
    static auto Get(Module& mod, Ty elem) -> ReferenceType*;
    static void Profile(FoldingSetNodeID& ID, Ty elem);
    static bool classof(const Type* e) { return e->kind() == Kind::ReferenceType; }
};

class srcc::ProcType final : public Type
    , public FoldingSetNode
    , TrailingObjects<ProcType, Ty> {
    friend TrailingObjects;

    CallingConvention cc;
    bool is_variadic;
    const u32 num_param_types;
    Ty return_type;

    auto numTrailingObjects(OverloadToken<Ty>) -> usz { return num_param_types; }

    ProcType(
        CallingConvention cconv,
        bool variadic,
        Ty return_type,
        ArrayRef<Ty> param_types
    );

public:
    /// Get the calling convention of this procedure type.
    auto cconv() const -> CallingConvention { return cc; }

    /// Get the parameter types of this procedure type.
    auto params() const -> ArrayRef<Ty> { return {getTrailingObjects<Ty>(), num_param_types}; }

    /// Get the return type of this procedure type.
    auto ret() const -> Ty { return return_type; }

    /// Get whether this procedure type is variadic.
    auto variadic() const -> bool { return is_variadic; }

    void Profile(FoldingSetNodeID& ID) const {
        Profile(ID, return_type, params(), cc, is_variadic);
    }

    static auto Get(
        Module& mod,
        Ty return_type,
        ArrayRef<Ty> param_types = {},
        CallingConvention cconv = CallingConvention::Source,
        bool variadic = false
    ) -> ProcType*;

    static void Profile(
        FoldingSetNodeID& ID,
        Ty return_type,
        ArrayRef<Ty> param_types,
        CallingConvention cconv,
        bool variadic
    );

    static bool classof(const Type* e) { return e->kind() == Kind::ProcType; }
};

class srcc::SliceType final : public SingleElementTypeBase
    , public FoldingSetNode {
    explicit SliceType(Ty elem) : SingleElementTypeBase{Kind::SliceType, elem} {}

public:
    void Profile(FoldingSetNodeID& ID) const { Profile(ID, elem()); }
    static auto Get(Module& mod, Ty elem) -> SliceType*;
    static void Profile(FoldingSetNodeID& ID, Ty elem);
    static bool classof(const Type* e) { return e->kind() == Kind::SliceType; }
};

template <typename To, typename From>
auto srcc::cast(srcc::TypeWrapper<From> from) -> srcc::TypeWrapper<To> {
    return srcc::TypeWrapper<To>{llvm::cast<To>(from.ptr())};
}

template <typename To, typename From>
auto srcc::dyn_cast(srcc::TypeWrapper<From> from) -> std::optional<srcc::TypeWrapper<To>> {
    if (auto* c = llvm::dyn_cast<To>(from.ptr())) return srcc::TypeWrapper<To>{c};
    return std::nullopt;
}

template <typename To, typename From>
auto srcc::isa(srcc::TypeWrapper<From> from) -> bool {
    return llvm::isa<To>(from.ptr());
}