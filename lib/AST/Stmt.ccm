module;

#include <llvm/Support/TrailingObjects.h>
#include <srcc/Macros.hh>
#include <memory>

export module srcc.ast:stmt;
import srcc;
import :enums;
import :type;

export namespace srcc {
#define AST_STMT(node) class node;
#include "srcc/AST.inc"
}

/// Root of the AST inheritance hierarchy.
class srcc::Stmt {
    SRCC_IMMOVABLE(Stmt);
    struct Printer;
    friend Printer;

public:
    enum struct Kind : u8 {
#define AST_STMT_LEAF(node) node,
#include "srcc/AST.inc"

    };

private:
    /// The kind of this statement.
    const Kind stmt_kind;

    /// Whether this statement is dependent, and how.
    Dependence dep = Dependence::None;

    /// Source location of this statement.
    Location loc;

protected:
    explicit Stmt(Kind kind, Location loc) : stmt_kind{kind}, loc{loc} {}

public:
    // Only allow allocating these in the module.
    void* operator new(usz) = SRCC_DELETED("Use `new (mod) { ... }` instead");
    void* operator new(usz size, Module& mod);

    /// Get whether this statement is dependent.
    [[nodiscard]] bool dependent() const { return dependence() & Dependence::Instantiation; }

    /// Get the dependence of this statement.
    [[nodiscard]] auto dependence() const -> Dependence { return dep; }

    /// Get the kind of this statement.
    [[nodiscard]] Kind kind() const { return stmt_kind; }

    /// Get the source location of this statement.
    [[nodiscard]] auto location() const -> Location { return loc; }

    /// Dump the statement.
    void dump(bool use_colour = false) const;
    void dump_color() const { dump(true); }

    /// Set the dependence of this statement.
    void set_dependence(Dependence d) { dep = d; }
};

// ============================================================================
//  Expressions.
// ============================================================================
class srcc::Expr : public Stmt {
public:
    /// Whether this expression is an lvalue.
    bool is_lvalue : 1 = false;

    /// The type of this expression.
    Type* type;

protected:
    Expr(
        Kind kind,
        Type* type,
        Location location
    ) : Stmt(kind, location), type{type} {}

public:
    /// Check if this expression is an lvalue.
    [[nodiscard]] bool lvalue() const { return is_lvalue; }

    /// Check if this expression is an rvalue.
    [[nodiscard]] bool rvalue() const { return not lvalue(); }

    /// Mark that this is an lvalue.
    void set_lvalue() { is_lvalue = true; }

    static bool classof(const Stmt* e) {
        return e->kind() >= Kind::BlockExpr and e->kind() <= Kind::StrLitExpr;
    }
};

class srcc::BlockExpr final : public Expr
    , TrailingObjects<BlockExpr, Stmt*> {
    friend TrailingObjects;

    const u32 num_stmts;

    auto numTrailingObjects(OverloadToken<Stmt*>) -> usz { return num_stmts; }

    BlockExpr(
        Type* type,
        ArrayRef<Stmt*> stmts,
        Location location
    );

public:
    static auto Create(
        Module& mod,
        Type* type,
        ArrayRef<Stmt*> stmts,
        Location location
    ) -> BlockExpr*;

    [[nodiscard]] auto stmts() -> ArrayRef<Stmt*> { return {getTrailingObjects<Stmt*>(), num_stmts}; }

    static bool classof(const Stmt* e) { return e->kind() == Kind::BlockExpr; }
};

class srcc::CallExpr final : public Expr
    , TrailingObjects<CallExpr, Expr*> {
    friend TrailingObjects;

public:
    Expr* callee;

private:
    const u32 num_args;

    auto numTrailingObjects(OverloadToken<Expr*>) -> usz { return num_args; }

    CallExpr(
        Type* type,
        Expr* callee,
        ArrayRef<Expr*> args,
        Location location
    );

public:
    static auto Create(
        Module& mod,
        Type* type,
        Expr* callee,
        ArrayRef<Expr*> args,
        Location location
    ) -> CallExpr*;

    [[nodiscard]] auto args() -> ArrayRef<Expr*> { return {getTrailingObjects<Expr*>(), num_args}; }

    static bool classof(const Stmt* e) { return e->kind() == Kind::CallExpr; }
};

class srcc::ProcRefExpr final : public Expr {
public:
    ProcDecl* decl;

private:
    ProcRefExpr(
        ProcDecl* decl,
        Location location
    );

public:
    static bool classof(const Stmt* e) { return e->kind() == Kind::ProcRefExpr; }
};

class srcc::StrLitExpr final : public Expr {
public:
    String value;

private:
    StrLitExpr(
        Module* mod,
        String value,
        Location location
    );

public:
    static bool classof(const Stmt* e) { return e->kind() == Kind::StrLitExpr; }
};

// ============================================================================
//  Declarations
// ============================================================================
class srcc::Decl : public Expr {
public:
    String name;

protected:
    Decl(
        Kind kind,
        Type* type,
        String name,
        Location location
    ) : Expr{kind, type, location}, name{name} {}

public:
    static bool classof(const Stmt* e) { return e->kind() >= Kind::ProcDecl; }
};

/// Declaration with linkage.
class srcc::ObjectDecl : public Decl {
public:
    Linkage linkage;
    Mangling mangling;

protected:
    ObjectDecl(
        Kind kind,
        Type* type,
        String name,
        Linkage linkage,
        Mangling mangling,
        Location location
    ) : Decl{kind, type, name, location},
        linkage{linkage},
        mangling{mangling} {}

public:
    static bool classof(const Stmt* e) { return e->kind() >= Kind::ProcDecl; }
};

/// Procedure declaration.
class srcc::ProcDecl final : public ObjectDecl {
public:
    /// May be null if this is a top-level procedure.
    ProcDecl* parent;

    /// Not set if this is e.g. external.
    Expr* body;

    ProcDecl(
        Type* type,
        String name,
        Linkage linkage,
        Mangling mangling,
        ProcDecl* parent,
        Expr* body,
        Location location
    ) : ObjectDecl{Kind::ProcDecl, type, name, linkage, mangling, location},
        parent{parent},
        body{body} {}

    static bool classof(const Stmt* e) { return e->kind() == Kind::ProcDecl; }
};
