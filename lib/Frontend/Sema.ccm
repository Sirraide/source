module;

#include <llvm/ADT/ArrayRef.h>
#include <llvm/ADT/TinyPtrVector.h>
#include <ranges>
#include <srcc/Macros.hh>

export module srcc.frontend.sema;
import srcc;
import srcc.utils;
import srcc.ast;
import srcc.token;
import srcc.langopts;
import srcc.frontend.parser;

export namespace srcc {
class Sema;
}

namespace srcc {
class TemplateInstantiator;
}

class srcc::Sema : DiagsProducer<std::nullptr_t> {
    SRCC_IMMOVABLE(Sema);

    class Importer;
    class ImmediateInitContext;
    class OverloadInitContext;

    friend DiagsProducer;
    friend TemplateInstantiator;
    friend Importer;

public:
    using TemplateArguments = DenseMap<TemplateTypeDecl*, TypeBase*>;

private:
    /// RAII Object to push and pop a scope.
    class [[nodiscard]] EnterScope {
    public:
        Sema& S;

    private:
        Scope* scope;

    public:
        EnterScope(Sema& S, bool proc_scope = false)
            : S{S} {
            auto sc = std::make_unique<Scope>(S.curr_scope(), proc_scope);
            scope = sc.get();
            S.scope_stack.push_back(scope);
            S.all_scopes.push_back(std::move(sc));
        }

        EnterScope(Sema& S, Scope* scope) : S{S} {
            S.scope_stack.push_back(scope);
        }

        /// Pop the scope if it is still active.
        ~EnterScope() {
            if (scope) S.scope_stack.pop_back();
        }

        /// Not copyable since copying scopes is nonsense.
        EnterScope(const EnterScope&) = delete;
        const EnterScope& operator=(const EnterScope&) = delete;

        /// However, we may want to pass these to functions in some cases
        /// to open a new scope or indicate that they do so.
        EnterScope(EnterScope&& other) : S{other.S}, scope{std::exchange(other.scope, nullptr)} {}
        EnterScope& operator=(EnterScope&& other) {
            Assert(&S == &other.S, "Cannot move scope between semas");
            scope = std::exchange(other.scope, nullptr);
            return *this;
        }

        /// Get the scope.
        auto get() const -> Scope* {
            Assert(scope, "Accessing scope after it has been moved");
            return scope;
        }
    };

    struct ProcScopeInfo {
        SRCC_IMMOVABLE(ProcScopeInfo);
        ProcDecl* proc;
        SmallVector<LocalDecl*> locals;
        const EnterScope es;

        ProcScopeInfo(Sema& S, ProcDecl* proc) : proc{proc}, es{S, proc->scope} {}
    };

    struct InstantiationScopeInfo : ProcScopeInfo {
        ProcDecl* pattern;
        DenseMap<LocalDecl*, LocalDecl*> local_instantiations;
        Location inst_loc;

        InstantiationScopeInfo(
            Sema& S,
            ProcDecl* pattern,
            ProcDecl* instantiation,
            Location inst_loc
        ) : ProcScopeInfo{S, instantiation}, pattern{pattern}, inst_loc{inst_loc} {}

        static bool classof(const ProcScopeInfo* info) {
            return info->proc->instantiated_from != nullptr;
        }
    };

    template <std::derived_from<ProcScopeInfo> ScopeInfo = ProcScopeInfo>
    class [[nodiscard]] EnterProcedure {
        SRCC_IMMOVABLE(EnterProcedure);
        ScopeInfo info;

        public:
        template <typename... Args>
        explicit EnterProcedure(Sema& S, ProcDecl* proc, Args&&... args)
            : info{S, proc, std::forward<Args>(args)...} {
            Assert(proc->scope, "Entering procedure without scope?");
            S.proc_stack.emplace_back(&info);
        }

        ~EnterProcedure() { info.es.S.proc_stack.pop_back(); }
    };

    /// A conversion from one type to another.
    struct Conversion {
        enum struct Kind : u8 {
            LValueToSRValue,
            SelectOverload
        };

        Kind kind;
        u16 index{};

        static auto LValueToSRValue() -> Conversion { return Conversion{Kind::LValueToSRValue}; }
        static auto SelectOverload(u16 index) -> Conversion { return Conversion{Kind::SelectOverload, index}; }
    };

    /// A (possibly empty) sequence of conversions applied to a type.
    using ConversionSequence = SmallVector<Conversion, 1>;

    /// The result of name lookup.
    struct LookupResult {
        enum struct Reason : u8 {
            /// Lookup was successful.
            Success,

            /// Lookup was ambiguous. This need not be an error if we’re
            /// looking up e.g. function overloads.
            Ambiguous,

            /// The name was not found.
            NotFound,

            /// One of the path segments did not name a scope.
            NonScopeInPath,
        };

        /// The decl(s) that were found, if any.
        llvm::TinyPtrVector<Decl*> decls;

        /// The name we failed to look up, if any. Will be unset
        /// if the lookup was successful.
        String name;

        /// Reason for failure.
        Reason result;

        LookupResult(String name) : name{name}, result{Reason::NotFound} {}
        LookupResult(ArrayRef<Decl*> decls, String name, Reason result) : decls{decls}, name{name}, result{result} {}

        /// Check if this lookup result is a success.
        [[nodiscard]] auto successful() const -> bool { return result == Reason::Success; }
        [[nodiscard]] explicit operator bool() const { return successful(); }

        /// Create an ambiguous lookup result.
        static auto Ambiguous(String name, ArrayRef<Decl*> decls) -> LookupResult { return LookupResult{decls, name, Reason::Ambiguous}; }
        static auto NonScopeInPath(String name, Decl* decl) -> LookupResult { return LookupResult{decl, name, Reason::NonScopeInPath}; }
        static auto Success(Decl* decl) -> LookupResult { return LookupResult{decl, "", Reason::Success}; }
    };

    /// The result of substituting a procedure type before template instantiation.
    struct TempSubstRes {
        /// Substitution was successful.
        struct Success {
            /// The substituted type.
            ProcType* type;

            /// The template argument list for instantiation.
            TemplateArguments args;
        };

        /// Deduction failed entirely for a TDD.
        struct DeductionFailed {
            /// The TTD that we failed to deduce.
            TemplateTypeDecl* ttd;

            /// The index of the parameter in which we tried to
            /// perform deduction.
            u32 param_index;
        };

        /// The type of a TDD decl was deduced to be two different types
        /// in two different parameters.
        struct DeductionAmbiguous {
            /// The TTD that we failed to deduce.
            TemplateTypeDecl* ttd;

            /// The two parameters that caused the ambiguity.
            u32 first, second;

            /// The two types that we deduced each time.
            Type first_type, second_type;
        };

        /// There was a hard error which has already been reported.
        struct Error {};

        /// What happened.
        Variant<Success, DeductionFailed, DeductionAmbiguous, Error> data = Error{};

        TempSubstRes() = default;
        TempSubstRes(Success&& s) : data{std::move(s)} {}
        TempSubstRes(DeductionFailed&& f) : data{std::move(f)} {}
        TempSubstRes(DeductionAmbiguous&& a) : data{std::move(a)} {}
    };

    // Overload resolution candidate.
    struct Candidate {
        // Viable candidate.
        struct Viable {
            // The conversion sequences that need to be applied to each
            // argument if this overload does get selected.
            SmallVector<ConversionSequence, 4> conversions;

            // How 'bad' is this overload, i.e. how many conversions are
            // required to make it work.
            u32 badness = 0;
        };

        // Candidate for which the argument count didn’t match the parameter count.
        struct ArgumentCountMismatch {};

        // Candidate for which there was something wrong with the arguments;
        // used for generic argument-related failures.
        struct TypeMismatch {
            // Which argument rendered it not viable.
            u32 mismatch_index;
        };

        // A candidate for which deduction failed entirely.
        struct InvalidTemplate {};

        // One of the arguments is an overload set, and we failed
        // to match any of the overloads against a parameter. This
        // has information about why each of the overloads didn’t
        // match. Because this only performs a subset of overload
        // resolution, it only needs to deal with a subset of failure
        // reasons.
        struct NestedResolutionFailure {
            // Index of the argument which contains this overload set.
            u32 mismatch_index;
        };

        // Info about a yet to be instantiated template.
        struct TemplateInfo {
            ProcDecl* pattern;
            TempSubstRes res;
        };

        // The procedure (template) that this candidate represents.
        using ProcInfo = Variant<ProcDecl*, TemplateInfo>;
        ProcInfo proc;

        // Whether this candidate is still viable, or why not.
        using Status = Variant<
            Viable,
            ArgumentCountMismatch,
            TypeMismatch,
            InvalidTemplate,
            NestedResolutionFailure>;
        Status status = Viable{};

        Candidate(ProcDecl* p) : proc{p} {}
        Candidate(ProcDecl* pattern, TempSubstRes&& res)
            : proc{TemplateInfo{pattern, std::move(res)}} {
            if (not res.data.is<TempSubstRes::Success>())
                status = InvalidTemplate{};
        }

        auto badness() const -> u32 { return status.get<Viable>().badness; }

        auto name() const -> String {
            return decl()->name;
        }

        auto location() const -> Location {
            return decl()->location();
        }

        auto param_loc(usz index) const -> Location {
            return decl()->params()[index]->location();
        }

        auto type() -> ProcType* {
            Assert(viable(), "Requesting type of non-viable candidate?");
            return proc.visit(utils::Overloaded{// clang-format off
                [](ProcDecl* p) { return p->proc_type(); },
                [](TemplateInfo& ti) { return ti.res.data.get<TempSubstRes::Success>().type; }
            }); // clang-format on
        }

        auto type_for_diagnostic() const -> ProcType* {
            if (auto p = proc.get<ProcDecl*>()) return p->proc_type();
            auto& ti = proc.get<TemplateInfo>();
            if (auto* s = ti.res.data.get_if<TempSubstRes::Success>()) return s->type;
            return ti.pattern->proc_type();
        }

        bool viable() { return status.is<Viable>(); }

    private:
        auto decl() const -> ProcDecl* {
            return proc.visit(utils::Overloaded{// clang-format off
                [](ProcDecl* p) { return p; },
                [](const TemplateInfo& ti) { return ti.pattern; }
            }); // clang-format on
        }
    };

    Context& ctx;
    TranslationUnit::Ptr M;
    ArrayRef<ParsedModule::Ptr> parsed_modules;

    /// All scopes that have been created.
    std::vector<std::unique_ptr<Scope>> all_scopes;

    /// Stack of active procedures.
    SmallVector<ProcScopeInfo*> proc_stack;

    /// Stack of active scopes.
    SmallVector<Scope*> scope_stack;

    /// Map from parsed procedures to their declarations.
    DenseMap<ParsedProcDecl*, ProcDecl*> proc_decl_map;

    /// Map from module names to imported modules.
    StringMap<TranslationUnit*> imported_modules;

    explicit Sema(Context& ctx) : ctx(ctx) {}

public:
    /// Analyse a set of parsed modules and combine them into a single module.
    ///
    /// @return The combined module, or `nullptr` if there was an error.
    [[nodiscard]] static auto Translate(
        const LangOpts& opts,
        ArrayRef<ParsedModule::Ptr> modules
    ) -> TranslationUnit::Ptr;

    /// Get the context.
    auto context() const -> Context& { return ctx; }

    /// Get the diagnostics engine.
    auto diags() const -> DiagnosticsEngine& { return ctx.diags(); }

    /// Get the current procedure.
    auto curr_proc() -> ProcScopeInfo& {
        Assert(not proc_stack.empty(), "Procedure stack underflow");
        return *proc_stack.back();
    }

    /// Get the current scope.
    auto curr_scope() -> Scope* { return scope_stack.back(); }

    /// Get the global scope.
    auto global_scope() -> Scope* { return scope_stack.front(); }

private:
    /// Add a declaration to a scope.
    ///
    /// This correctly handles redeclarations and declarations
    /// with an empty name.
    void AddDeclToScope(Scope* scope, Decl* d);

    /// Adjust a type for use in a variable declaration.
    [[nodiscard]] auto AdjustVariableType(Type ty, Location loc) -> Type;

    /// Apply a conversion to an expression.
    [[nodiscard]] auto ApplyConversion(Expr* e, Conversion conv) -> Expr*;

    /// Apply a conversion sequence to an expression.
    [[nodiscard]] auto ApplyConversionSequence(Expr* e, ConversionSequence& seq) -> Expr*;

    /// Create a reference to a declaration.
    [[nodiscard]] auto CreateReference(Decl* d, Location loc) -> Ptr<Expr>;

    /// Add a variable to the current scope and procedure.
    void DeclareLocal(LocalDecl* d);

    /// Perform template deduction.
    ///
    /// Returns Types::ErrorDependentTy on deduction failure, and
    /// an empty optional on a hard error.
    auto DeduceType(
        TemplateTypeDecl* ty,
        Type param,
        Type arg
    ) -> Opt<Type>;

    /// Extract the scope that is the body of a declaration, if it has one.
    auto GetScopeFromDecl(Decl* d) -> Ptr<Scope>;

    /// Ensure that an expression is an srvalue of the given type. This is
    /// mainly used for expressions involving operators.
    bool MakeSRValue(Type ty, Expr*& e, StringRef elem_name, StringRef op);

    /// Import a C++ header as a module.
    auto ImportCXXHeader(Location import_loc, String linkage_name) -> TranslationUnit::Ptr;

    /// Instantiate a procedure template.
    auto InstantiateTemplate(
        ProcDecl* proc,
        ProcType* substituted_type,
        TemplateArguments& args,
        Location inst_loc
    ) -> Ptr<ProcDecl>;

    /// Traverse scopes of procedures that we’re instantiating.
    auto InstantiationStack() {
        return proc_stack                                   //
             | vws::filter(InstantiationScopeInfo::classof) //
             | vws::transform([](auto x) { return static_cast<InstantiationScopeInfo*>(x); });
    }

    /// Use LookUpName() instead.
    auto LookUpQualifiedName(Scope* in_scope, ArrayRef<String> names) -> LookupResult;

    /// Perform unqualified name lookup.
    auto LookUpUnqualifiedName(
        Scope* in_scope,
        String name,
        bool this_scope_only
    ) -> LookupResult;

    /// Look up a name in a scope.
    ///
    /// Name lookup differs between unqualified and qualified names: for
    /// unqualified names, we look up the name in the scope it was encountered
    /// in, and all of its parent scope.
    ///
    /// For qualified name lookup, we start by performing unqualified lookup
    /// for the first name in the path, except that names of imported modules
    /// are also considered if all else fails. The remaining path segments are
    /// then looked up in the scope of the declaration found by the previous
    /// segment only.
    ///
    /// \param in_scope The scope to start searching in.
    /// \param names The path to look up.
    /// \param loc The location of the lookup.
    /// \param complain Emit a diagnostic if lookup fails.
    auto LookUpName(
        Scope* in_scope,
        ArrayRef<String> names,
        Location loc,
        bool complain = true
    ) -> LookupResult;

    /// Convert an lvalue to an srvalue.
    [[nodiscard]] auto LValueToSRValue(Expr* expr) -> Expr*;

    /// Materialise a temporary value.
    [[nodiscard]] auto MaterialiseTemporary(Expr* expr) -> Expr*;

    /// Resolve an overload set.
    auto PerformOverloadResolution();

    /// Initialise a variable from an expression.
    template <typename InitContext>
    bool PerformVariableInitialisation(
        InitContext& ctx,
        Type param_type,
        Expr* arg
    );

    /// Issue an error about lookup failure.
    void ReportLookupFailure(const LookupResult& result, Location loc);

    /// Issue an error about overload resolution failure.
    void ReportOverloadResolutionFailure(
        ArrayRef<Candidate> candidates,
        ArrayRef<Expr*> call_args,
        Location call_loc,
        u32 final_badness
    );

    /// Substitute types in a procedure template.
    auto SubstituteTemplate(
        ProcDecl* proc_template,
        ArrayRef<TypeLoc> input_types,
        Location inst_loc
    ) -> TempSubstRes;

    /// Building AST nodes; called after translation and template instantiation.
    auto BuildAssertExpr(Expr* cond, Ptr<Expr> msg, Location loc) -> Ptr<AssertExpr>;
    auto BuildBinaryExpr(Tk op, Expr* lhs, Expr* rhs, Location loc) -> Ptr<BinaryExpr>;
    auto BuildBlockExpr(Scope* scope, ArrayRef<Stmt*> stmts, Location loc) -> BlockExpr*;
    auto BuildBuiltinCallExpr(BuiltinCallExpr::Builtin builtin, ArrayRef<Expr*> args, Location call_loc) -> Ptr<BuiltinCallExpr>;
    auto BuildCallExpr(Expr* callee_expr, ArrayRef<Expr*> args, Location loc) -> Ptr<CallExpr>;
    auto BuildEvalExpr(Stmt* arg, Location loc) -> Ptr<Expr>;
    auto BuildLocalDecl(ProcScopeInfo& proc, Type ty, String name, Ptr<Expr> init, Location loc) -> LocalDecl*;
    auto BuildParamDecl(ProcScopeInfo& proc, Type ty, String name, Location loc) -> ParamDecl*;
    auto BuildProcBody(ProcDecl* proc, Expr* body) -> Ptr<Expr>;
    auto BuildReturnExpr(Ptr<Expr> value, Location loc, bool implicit) -> ReturnExpr*;
    auto BuildTypeExpr(Type ty, Location loc) -> TypeExpr*;
    auto BuildUnaryExpr(Tk op, Expr* operand, bool postfix, Location loc) -> Ptr<UnaryExpr>;

    /// Entry point.
    void Translate();

    /// Statements.
#define PARSE_TREE_LEAF_NODE(Name) auto Translate##Name(Parsed##Name* parsed)->Ptr<Expr>;
#define PARSE_TREE_LEAF_DECL(Name) auto Translate##Name(Parsed##Name* parsed)->Decl*;
#define PARSE_TREE_LEAF_TYPE(Name)
#include "srcc/ParseTree.inc"

    auto TranslateExpr(ParsedStmt* parsed) -> Ptr<Expr>;

    /// Declarations.
    auto TranslateEntireDecl(Decl* decl, ParsedDecl* parsed) -> Ptr<Decl>;
    auto TranslateDeclInitial(ParsedDecl* parsed) -> std::optional<Ptr<Decl>>;
    auto TranslateProc(ProcDecl* decl, ParsedProcDecl* parsed) -> Ptr<ProcDecl>;
    auto TranslateProcBody(ProcDecl* decl, ParsedProcDecl* parsed) -> Ptr<Stmt>;
    auto TranslateProcDeclInitial(ParsedProcDecl* parsed) -> Ptr<ProcDecl>;
    auto TranslateStmt(ParsedStmt* parsed) -> Ptr<Stmt>;
    auto TranslateStmts(SmallVectorImpl<Stmt*>& stmts, ArrayRef<ParsedStmt*> parsed) -> void;

    /// Types.
    auto TranslateBuiltinType(ParsedBuiltinType* parsed) -> Type;
    auto TranslateNamedType(ParsedDeclRefExpr* parsed) -> Type;
    auto TranslateTemplateType(ParsedTemplateType* parsed) -> Type;
    auto TranslateType(ParsedStmt* stmt) -> Type;

    auto TranslateProcType(
        ParsedProcType* parsed,
        SmallVectorImpl<TemplateTypeDecl*>* ttds = nullptr
    ) -> Type;

    template <typename... Args>
    void Diag(Diagnostic::Level lvl, Location where, std::format_string<Args...> fmt, Args&&... args) {
        ctx.diags().diag(lvl, where, fmt, std::forward<Args>(args)...);
        if (lvl != Diagnostic::Level::Note)
            for (auto i : InstantiationStack() | vws::reverse)
                ctx.diags().add_extra_location(i->inst_loc, "in instantiation of '{}'", i->pattern->name);
    }
};
