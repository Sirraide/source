module;

#include <algorithm>
#include <bit>
#include <filesystem>
#include <fmt/format.h>
#include <llvm/Support/Error.h>
#include <llvm/Support/MemoryBuffer.h>
#include <source_location>
#include <srcc/Macros.hh>
#include <string>
#include <string_view>
#include <mutex>

export module srcc;
import srcc.utils;

export namespace srcc {
class Context;
class Diag;
class File;

struct Location;
struct LocInfo;
struct LocInfoShort;

namespace detail {
template <typename T>
concept ValidResultType = std::is_same_v<std::remove_cvref_t<T>, T> and not std::is_same_v<T, Diag>;
}

template <detail::ValidResultType ValueType>
class Result;
} // namespace srcc

/// A decoded source location.
struct srcc::LocInfo {
    usz line;
    usz col;
    const char* line_start;
    const char* line_end;
};

/// A short decoded source location.
struct srcc::LocInfoShort {
    usz line;
    usz col;
};

/// A source range in a file.
struct srcc::Location {
    u32 pos{};
    u16 len{};
    u16 file_id{};

    constexpr Location() = default;
    constexpr Location(u32 pos, u16 len, u16 file_id)
        : pos(pos), len(len), file_id(file_id) {}

    /// Create a new location that spans two locations.
    constexpr Location(Location a, Location b) {
        if (a.file_id != b.file_id) return;
        if (not a.is_valid() or not b.is_valid()) return;
        pos = std::min<u32>(a.pos, b.pos);
        len = u16(std::max<u32>(a.pos + a.len, b.pos + b.len) - pos);
    }

    /// Shift a source location to the left.
    [[nodiscard]] constexpr auto operator<<(isz amount) const -> Location {
        Location l = *this;
        if (not is_valid()) return l;
        l.pos = std::min(pos, u32(pos - u32(amount)));
        return l;
    }

    /// Shift a source location to the right.
    [[nodiscard]] constexpr auto operator>>(isz amount) const -> Location {
        Location l = *this;
        l.pos = std::max(pos, u32(pos + u32(amount)));
        return l;
    }

    /// Extend a source location to the left.
    [[nodiscard]] constexpr auto operator<<=(isz amount) const -> Location {
        Location l = *this << amount;
        l.len = std::max(l.len, u16(l.len + amount));
        return l;
    }

    /// Extend a source location to the right.
    [[nodiscard]] constexpr auto operator>>=(isz amount) const -> Location {
        Location l = *this;
        l.len = std::max(l.len, u16(l.len + amount));
        return l;
    }

    /// Contract a source location to the left.
    [[nodiscard]] constexpr auto contract_left(isz amount) const -> Location {
        if (amount > len) return {};
        Location l = *this;
        l.len = u16(l.len - amount);
        return l;
    }

    /// Contract a source location to the right.
    [[nodiscard]] constexpr auto contract_right(isz amount) const -> Location {
        if (amount > len) return {};
        Location l = *this;
        l.pos = u32(l.pos + u32(amount));
        l.len = u16(l.len - amount);
        return l;
    }

    /// Encode a location as a 64-bit number.
    [[nodiscard]] constexpr u64 encode() const { return std::bit_cast<u64>(*this); }

    [[nodiscard]] constexpr bool is_valid() const { return len != 0; }

    /// Seek to a source location.
    [[nodiscard]] auto seek(const Context& ctx) const -> std::optional<LocInfo>;

    /// Seek to a source location, but only return the line and column.
    [[nodiscard]] auto seek_line_column(const Context& ctx) const -> std::optional<LocInfoShort>;

    /// Get the text pointed to by this source location.
    ///
    /// This returns a StringRef instead of a String because the returned
    /// range is almost certainly not null-terminated.
    [[nodiscard]] auto text(const Context& ctx) const -> StringRef;

    /// Decode a source location from a 64-bit number.
    static constexpr auto Decode(u64 loc) -> Location {
        return std::bit_cast<Location>(loc);
    }

private:
    [[nodiscard]] bool seekable(const Context& ctx) const;
};

/// All members of 'Context' are thread-safe.
class srcc::Context {
    SRCC_DECLARE_HIDDEN_IMPL(Context);

public:
    /// Create a new context with default options.
    explicit Context();

    /// Enable or disable coloured output.
    void enable_colours(bool enable);

    /// Mark that an error has occurred.
    void set_error() const;

    /// Get a file by index. Returns nullptr if the index is out of bounds.
    [[nodiscard]] auto file(usz idx) const -> const File*;

    /// Get a file from disk.
    ///
    /// This will load the file the first time it is requested.
    [[nodiscard]] auto get_file(const fs::path& path) -> const File&;

    /// Check if an error has occurred.
    [[nodiscard]] auto has_error() const -> bool;

    /// Lock the mutex used for reporting diagnostics.
    [[nodiscard]] auto lock_diags_mutex() const -> std::unique_lock<std::recursive_mutex>;

    /// Whether to enable coloured output.
    [[nodiscard]] bool use_colours() const;
};

/// A diagnostic. The diagnostic is issued when the destructor is called.
class srcc::Diag {
public:
    /// Diagnostic severity.
    enum struct Kind : u8 {
        None,    ///< Do not emit this diagnostic.
        Note,    ///< Informational note.
        Warning, ///< Warning, but no hard error.
        Error,   ///< Hard error. Program is ill-formed.
        Fatal,   ///< Fatal (system) error. NOT a compiler bug.
        ICE,     ///< Compiler bug.
    };

private:
    const Context* ctx{};
    Kind kind{Kind::None};
    bool include_stack_trace = true;
    Location where{};
    std::source_location sloc{};
    std::string msg;

    /// Handle fatal error codes.
    void HandleFatalErrors();

    /// Print a diagnostic with no (valid) location info.
    void PrintDiagWithoutLocation(utils::Colours);

public:
    static constexpr u8 ICEExitCode = 17;
    static constexpr u8 FatalExitCode = 18;

    Diag(Diag&& other)
        : ctx(other.ctx), kind(other.kind), where(other.where), msg(std::move(other.msg)) {
        other.kind = Kind::None;
    }

    Diag& operator=(Diag&& other) {
        if (this == &other) return *this;
        ctx = other.ctx;
        kind = other.kind;
        where = other.where;
        msg = std::move(other.msg);
        other.kind = Kind::None;
        return *this;
    }

    /// Create an empty diagnostic.
    explicit Diag() = default;

    /// Disallow copying.
    Diag(const Diag&) = delete;
    Diag& operator=(const Diag&) = delete;

    /// The destructor prints the diagnostic, if it hasnâ€™t been moved from.
    ~Diag() {
        if (kind != Kind::None) print();
    }

    /// Issue a diagnostic.
    Diag(const Context& ctx, Kind kind, Location where, std::string msg)
        : ctx(&ctx), kind(kind), where(where), msg(std::move(msg)) {}

    /// Issue a diagnostic with no location.
    Diag(Kind _kind, std::string&& msg, std::source_location sloc = {})
        : kind(_kind), sloc(sloc), msg(std::move(msg)) {}

    /// Issue a diagnostic with a format string and arguments.
    template <typename... Args>
    Diag(
        const Context& ctx,
        Kind kind,
        Location where,
        fmt::format_string<Args...> fmt,
        Args&&... args
    ) : Diag{ctx, kind, where, fmt::format(fmt, std::forward<Args>(args)...)} {}

    /// Issue a diagnostic with a format string and arguments, but no location.
    template <typename... Args>
    Diag(Kind kind, fmt::format_string<Args...> fmt, Args&&... args)
        : Diag{kind, fmt::format(fmt, std::forward<Args>(args)...)} {}

    /// Check whether this diagnostic is suppressed.
    [[nodiscard]] bool is_suppressed() const { return kind == Kind::None; }

    /// Do not print a stack trace.
    void no_trace() { include_stack_trace = false; }

    /// Print this diagnostic now. This resets the diagnostic.
    void print();

    /// Suppress this diagnostic.
    void suppress() { kind = Kind::None; }

    /// Emit a note.
    template <typename... Args>
    static Diag Note(fmt::format_string<Args...> fmt, Args&&... args) {
        return Diag{Kind::Note, fmt::format(fmt, std::forward<Args>(args)...)};
    }

    /// Emit a note.
    template <typename... Args>
    static Diag Note(
        const Context& ctx,
        Location where,
        fmt::format_string<Args...> fmt,
        Args&&... args
    ) {
        return Diag{ctx, Kind::Note, where, fmt::format(fmt, std::forward<Args>(args)...)};
    }

    /// Emit a warning.
    template <typename... Args>
    static Diag Warning(fmt::format_string<Args...> fmt, Args&&... args) {
        return Diag{Kind::Warning, fmt::format(fmt, std::forward<Args>(args)...)};
    }

    /// Emit a warning.
    template <typename... Args>
    static Diag Warning(
        const Context& ctx,
        Location where,
        fmt::format_string<Args...> fmt,
        Args&&... args
    ) {
        return Diag{ctx, Kind::Warning, where, fmt::format(fmt, std::forward<Args>(args)...)};
    }

    /// Emit an error.
    template <typename... Args>
    static Diag Error(
        fmt::format_string<Args...> fmt,
        Args&&... args
    ) {
        return Diag{Kind::Error, fmt::format(fmt, std::forward<Args>(args)...)};
    }

    /// Emit an error.
    template <typename... Args>
    static Diag Error(
        const Context& ctx,
        Location where,
        fmt::format_string<Args...> fmt,
        Args&&... args
    ) {
        return Diag{ctx, Kind::Error, where, fmt::format(fmt, std::forward<Args>(args)...)};
    }

    /// Raise an internal compiler error and exit.
    template <typename... Args>
    [[noreturn]] static void ICE(
        utils::FStringWithSrcLoc<Args...> fmt,
        Args&&... args
    ) {
        Diag{Kind::ICE, fmt::format(fmt.fmt, std::forward<Args>(args)...), fmt.sloc};
        std::terminate(); /// Should never be reached.
    }

    /// Raise an internal compiler error and exit.
    template <typename... Args>
    [[noreturn]] static void ICENoTrace(
        utils::FStringWithSrcLoc<Args...> fmt,
        Args&&... args
    ) {
        Diag{Kind::ICE, fmt::format(fmt.fmt, std::forward<Args>(args)...), fmt.sloc}.no_trace();
        std::terminate(); /// Should never be reached.
    }

    /// Raise an internal compiler error at a location and exit.
    template <typename... Args>
    [[noreturn]] static void ICE(
        const Context& ctx,
        Location where,
        fmt::format_string<Args...> fmt,
        Args&&... args
    ) {
        Diag{ctx, Kind::ICE, where, fmt::format(fmt, std::forward<Args>(args)...)};
        std::terminate(); /// Should never be reached.
    }

    /// Raise a fatal error and exit.
    ///
    /// This is NOT an ICE; instead it is an error that is probably caused by
    /// the underlying system, such as attempting to output to a directory that
    /// isnâ€™t accessible to the user.
    template <typename... Args>
    [[noreturn]] static void Fatal(
        utils::FStringWithSrcLoc<Args...> fmt,
        Args&&... args
    ) {
        Diag{Kind::Fatal, fmt::format(fmt.fmt, std::forward<Args>(args)...), fmt.sloc};
        std::terminate(); /// Should never be reached.
    }


    /// Enable coloured output by default. This is overriden by the corresponding
    /// setting in the context.
    static void EnableColours(bool enable);

    /// Set the output stream that diagnostics (excluding ICEs and Assertions)
    /// will be issued to.
    static void SetDiagsStream(llvm::raw_ostream& stream);
};

/// Represents the result of a computation, or an error.
template <srcc::detail::ValidResultType Ty = void>
class srcc::Result {
public:
    using ValueType = Ty;

private:
    std::variant<Ty, Diag> data;

public:
    /// Create an result that contains a default-constructed value.
    Result()
    requires std::is_default_constructible_v<Ty>
        : data(Ty()) {}

    /// Disallow construction from nullptr for pointers. Use
    /// Result::UnsafeNull() instead.
    Result(std::nullptr_t)
    requires std::is_pointer_v<Ty>
    = SRCC_DELETED(
        "Avoid creating nullptr results; "
        "use Result::UnsafeNull() if absolutely necessary"
    );

    /// Create a result from the value type.
    Result(Ty ty) : data(std::move(ty)) {}

    /// Create a result that contains a diagnostic.
    Result(Diag d) : data(std::move(d)) {}

    /// Access the error; this automatically moves to simplify propagating errors.
    [[nodiscard]] auto error() -> Diag&& {
        Assert(std::holds_alternative<Diag>(data), "Result must hold a error");
        return std::move(std::get<Diag>(data));
    }

    /// Access the value.
    [[nodiscard]] auto operator*() -> Ty& {
        Assert(std::holds_alternative<Ty>(data), "Result must hold a value");
        return std::get<Ty>(data);
    }

    /// Access the value.
    [[nodiscard]] auto operator->() -> Ty* requires (not std::is_pointer_v<Ty>) {
        Assert(std::holds_alternative<Ty>(data), "Result must hold a value");
        return std::addressof(std::get<Ty>(data));
    }

    /// Access the value.
    [[nodiscard]] auto
    operator->() -> Ty
    requires std::is_pointer_v<Ty>
    {
        Assert(std::holds_alternative<Ty>(data), "Result must hold a value");
        return std::get<Ty>(data);
    }

    /// Check whether this contains a value.
    [[nodiscard]] explicit operator bool() { return std::holds_alternative<Ty>(data); }
};

template <>
class srcc::Result<void> {
public:
    using ValueType = void;

private:
    // Diag already has an empty state; no need to bother
    // w/ optionals here.
    Diag diag;

public:
    /// Create an result that contains an empty error.
    Result() = default;
    Result(const Result&) = delete;
    Result& operator=(const Result&) = delete;
    Result(Result&&) = default;
    Result& operator=(Result&&) = default;

    /// Create a result that contains a diagnostic.
    Result(Diag d) : diag(std::move(d)) {}

    /// Transform an LLVM error to a diagnostic.
    template <typename Formatter>
    [[nodiscard]] static auto Error(llvm::Error&& e, Formatter format) -> Result {
        if (e) {
            std::string Text;
            handleAllErrors(std::move(e), [&](const llvm::ErrorInfoBase& e) { Text = format(e); });
            return Diag::Error("{}", Text);
        }

        return {};
    }

    /// Access the error; this automatically moves to simplify propagating errors.
    [[nodiscard]] auto error() -> Diag&& {
        Assert(not diag.is_suppressed(), "Result must hold a error");
        return std::move(diag);
    }

    /// Check whether this contains a value.
    [[nodiscard]] explicit operator bool() const { return diag.is_suppressed(); }
};

/// A file in the context.
class srcc::File {
    SRCC_IMMOVABLE(File);

public:
    /// Path type used by the file system.
    using Path = fs::path;

private:
    /// Context handle.
    Context& ctx;

    /// The absolute file path.
    Path file_path;

    /// The name of the file as specified on the command line.
    std::string file_name;

    /// The contents of the file.
    std::unique_ptr<llvm::MemoryBuffer> contents;

    /// The id of the file.
    const i32 id;

public:
    /// Get an iterator to the beginning of the file.
    [[nodiscard]] auto begin() const { return contents->getBufferStart(); }

    /// Get the owning context.
    [[nodiscard]] auto context() const -> Context& { return ctx; }

    /// Get the file data.
    [[nodiscard]] auto data() const -> const char* { return contents->getBufferStart(); }

    /// Get an iterator to the end of the file.
    [[nodiscard]] auto end() const { return contents->getBufferEnd(); }

    /// Get the id of this file.
    [[nodiscard]] auto file_id() const { return id; }

    /// Get the short file name.
    [[nodiscard]] auto name() const -> StringRef { return file_name; }

    /// Get the file path.
    [[nodiscard]] auto path() const -> const Path& { return file_path; }

    /// Get the size of the file.
    [[nodiscard]] auto size() const -> isz { return isz(contents->getBufferSize()); }

    /// Get a temporary file path.
    [[nodiscard]] static auto TempPath(StringRef extension) -> Path;

    /// Write to a file on disk.
    [[nodiscard]] static auto Write(const void* data, usz size, const Path& file) -> Result<>;

    /// Write to a file on disk and terminate on error.
    static void WriteOrDie(void* data, usz size, const Path& file);

private:
    /// The context is the only thing that can create files.
    friend Context;

    /// Construct a file from a name and source.
    explicit File(
        Context& ctx,
        Path path,
        std::string name,
        std::unique_ptr<llvm::MemoryBuffer> contents,
        u16 id
    );

    /// Load a file from disk.
    static auto LoadFileData(const Path& path) -> std::unique_ptr<llvm::MemoryBuffer>;
};
