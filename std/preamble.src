__srcc_preamble__

// TODO: If the body of a procedure is a 'match' expression, use its
// declared return type (if it has one) as the result type of the
// 'match' expression.
proc ** (in $T base, copy $T exp) __srcc_builtin_op__ -> T = match -> T {
    // Anything to the power of 0 is 1.
    exp == 0: 1;

    // Raising 0 to any non-negative power is 0. Raising 0 to a negative
    // power is an error since that is just division by zero.
    //
    // TODO: Introduce a ‘desired type’ in Sema that is passed to every call to
    // 'TranslateXY()' which can be used to convert e.g. '{ 1; }' from an 'int'
    // to an 'i8'. This will be required anyway for enumerators.
    base == 0: {
        assert exp >= 0, "attempting to raise 0 to a negative power";
        0;
    } as T;

    // Raising to a negative power.
    //
    // For any number that isn't -1 or 1, this results in a fraction in
    // the interval (-1, 1), which for integers is just 0.
    exp < 0: match base {
        -1: if exp & 1 != 0 then -1; else 1;
        1: 1;
        _: 0;
    } as T;

    // Perform the exponentiation.
    _: {
        T v = base;
        while exp != 1 {
            v *= base;
            exp -= 1;
        }; // FIXME: This semicolon should not be required but the parser treats '{} v' as a declaration...

        // We're done once 'exp' is 1.
        v;
    };
}

proc **= (inout $T base, in $T exp) __srcc_builtin_op__ -> T^ {
    base = base ** exp;
    return &base;
}

// FIXME: Should be '$T[]'
proc == (in $T a, in T b) __srcc_builtin_op__ -> bool {
    if a.size != b.size return false;
    for v1, v2 in a, b if v1 != v2 return false;
    return true;
}

/// Payload passed to various assertion handlers.
///
/// The name and layout of this type are hard-coded into the
/// compiler. DO NOT MODIFY!
struct __src_abort_info {
    i8[] filename;
    int line;
    int col;
    i8[] msg1;
    i8[] msg2;
}
