__srcc_preamble__

proc ** (in $T base, copy $T exp) __srcc_builtin_op__ -> T = match {
    // Anything to the power of 0 is 1.
    exp == 0: 1;

    // Raising 0 to any non-negative power is 0. Raising 0 to a negative
    // power is an error since that is just division by zero.
    base == 0: {
        assert exp >= 0, "attempting to raise 0 to a negative power";
        0;
    };

    // Raising to a negative power.
    //
    // For any number that isn't -1 or 1, this results in a fraction in
    // the interval (-1, 1), which for integers is just 0.
    exp < 0: match base {
        -1: if exp & 1 != 0 then -1; else 1;
        1: 1;
        _: 0;
    };

    // Perform the exponentiation.
    _: {
        var v = base;
        while exp != 1 {
            v *= base;
            exp -= 1;
        }; // FIXME: This semicolon should not be required but the parser treats '{} v' as a declaration...

        // We're done once 'exp' is 1.
        v;
    };
}

proc **= (inout $T base, in $T exp) __srcc_builtin_op__ -> T^ {
    base = base ** exp;
    return &base;
}

// FIXME: Should be '$T[]'
proc == (in $T a, in T b) __srcc_builtin_op__ -> bool {
    if a.size != b.size return false;
    for v1, v2 in a, b if v1 != v2 return false;
    return true;
}

