module __src_runtime;

import <cstdlib>, <cstdio> as libc;

/// Payload passed to various assertion handlers.
///
/// The layout of this type is hard-coded into the compiler.
/// DO NOT MODIFY!
export struct AbortInfo {
    i8[] filename;
    int line;
    int col;
    i8[] msg1;
    i8[] msg2;
}

/// Program entry point generated by the compiler.
proc __src_main extern nomangle;

/// Print the location at which an error occurred.
proc print_file (in AbortInfo info) {
    var filename = info.filename;
    if filename.size == 0 then filename = "<invalid filename>";

    // FIXME: Using printf might be a problem if this is called from inside a
    // signal handler; switch to using write() instead on linux (the same applies
    // to some of the other printf() calls below).
    libc::printf(
        "Fatal Error at %.*s:%zu:%zu\n".data,
        filename.size as __srcc_ffi_int,
        filename.data,
        info.line,
        info.col
    );
}

/// Arithmetic failure handler.
///
/// The __src_abort_info type passed to these handlers does not
/// need to be exported by this because itâ€™s part of the preamble,
/// so it should always be available.
export proc __src_int_arith_error (AbortInfo^ info) native -> noreturn {
    print_file(^info);
    libc::printf(
        "    %.*s while evaluating '%.*s'\n".data,
        info.msg2.size as __srcc_ffi_int,
        info.msg2.data,
        info.msg1.size as __srcc_ffi_int,
        info.msg1.data,
    );
    libc::abort();
}

/// Assertion handler.
export proc __src_assert_fail (AbortInfo^ info) native -> noreturn {
    print_file(^info);
    libc::printf(
        "    assertion '%.*s' failed".data,
        info.msg1.size as __srcc_ffi_int,
        info.msg1.data,
    );

    if info.msg2.size != 0 then libc::printf(
        ": %.*s".data,
        info.msg2.size as __srcc_ffi_int,
        info.msg2.data,
    );

    libc::putchar("\n"[0]);
    libc::abort();
}

/// Declare our own initialiser so we can call it.
///
/// Unlike other modules, the runtime is not initialised when it is
/// imported (this is mostly an optimisation to avoid having to call
/// its initialiser in *every* module, and also because we might not
/// have a runtime); this means that we need to initialise ourselves.
proc \(__src_static_init.__src_runtime) extern nomangle;

/// Entry point called by the C runtime.
export proc __src_runtime_entry(
    __srcc_ffi_int argc,
    __srcc_ffi_char^^ argv,
) native {
    \(__src_static_init.__src_runtime)();
    __src_main();
}
