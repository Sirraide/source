module __src_runtime;
// TODO: Add a builtin module option to forbid top-level code that isn’t
// a declaration since this needs to be called from C, which doesn’t know about
// our module initialisers.

import <cstdlib>, <cstdio> as libc;

/// Payload passed to various assertion handlers.
///
/// The layout of this type are hard-coded into the compiler.
/// DO NOT MODIFY!
///
/// FIXME: All the functions below that receive an 'in AbortInfo' should
/// actually take an 'AbortInfo^' because this is always passed by pointer
/// irrespective of ABI or target.
export struct AbortInfo {
    i8[] filename;
    int line;
    int col;
    i8[] msg1;
    i8[] msg2;
}

/// Program entry point generated by the compiler.
proc __src_main extern nomangle;

/// Print the location at which an error occurred.
proc print_file (in AbortInfo info) {
    var filename = info.filename;
    if filename.size == 0 then filename = "<invalid filename>";

    // FIXME: Using printf might be a problem if this is called from inside a
    // signal handler; switch to using write() instead on linux (the same applies
    // to some of the other printf() calls below).
    libc::printf(
        "Fatal Error at %.*s:%zu:%zu\n".data,
        filename.size as __srcc_ffi_int,
        filename.data,
        info.line,
        info.col
    );
}

/// Arithmetic failure handler.
///
/// The __src_abort_info type passed to these handlers does not
/// need to be exported by this because it’s part of the preamble,
/// so it should always be available.
export proc __src_int_arith_error (in AbortInfo info) native -> noreturn {
    print_file(info);
    libc::printf(
        "    %.*s while evaluating '%.*s'\n".data,
        info.msg2.size as __srcc_ffi_int,
        info.msg2.data,
        info.msg1.size as __srcc_ffi_int,
        info.msg1.data,
    );
    libc::abort();
}

/// Assertion handler.
export proc __src_assert_fail (in AbortInfo info) native -> noreturn {
    print_file(info);
    libc::printf(
        "    assertion '%.*s' failed".data,
        info.msg1.size as __srcc_ffi_int,
        info.msg1.data,
    );

    if info.msg2.size != 0 then libc::printf(
        ": %.*s".data,
        info.msg2.size as __srcc_ffi_int,
        info.msg2.data,
    );

    libc::putchar("\n"[0]);
    libc::abort();
}

/// Entry point called by the C runtime.
export proc __src_runtime_entry(
    __srcc_ffi_int argc,
    __srcc_ffi_char^^ argv,
) native {
    __src_main();
}
