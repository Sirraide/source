module __src_runtime;

import <cstdlib>, <cstdio> as libc;

/// Payload passed to various assertion handlers.
///
/// The layout of this type is hard-coded into the compiler.
/// DO NOT MODIFY!
export struct AbortInfo {
    i8[] filename;
    int line;
    int col;
    i8[] msg1;
    i8[] msg2;
}

/// Program entry point generated by the compiler.
proc __src_main extern nomangle;

/// Print the location at which an error occurred.
proc print_file (in AbortInfo info) {
    var filename = info.filename;
    if filename.size == 0 then filename = "<invalid filename>";

    // FIXME: Using printf might be a problem if this is called from inside a
    // signal handler; switch to using write() instead on linux (the same applies
    // to some of the other printf() calls below).
    libc::printf(
        "Fatal Error at %.*s:%zu:%zu\n".data,
        filename.size as __srcc_ffi_int,
        filename.data,
        info.line,
        info.col
    );
}

/// Arithmetic failure handler.
///
/// The __src_abort_info type passed to these handlers does not
/// need to be exported by this because itâ€™s part of the preamble,
/// so it should always be available.
export proc __src_int_arith_error (AbortInfo^ info) native -> noreturn {
    print_file(^info);
    libc::printf(
        "    %.*s while evaluating '%.*s'\n".data,
        info.msg2.size as __srcc_ffi_int,
        info.msg2.data,
        info.msg1.size as __srcc_ffi_int,
        info.msg1.data,
    );
    libc::abort();
}

/// Assertion handler.
export proc __src_assert_fail (AbortInfo^ info) native -> noreturn {
    print_file(^info);
    libc::printf(
        "    assertion '%.*s' failed".data,
        info.msg1.size as __srcc_ffi_int,
        info.msg1.data,
    );

    if info.msg2.size != 0 then libc::printf(
        ": %.*s".data,
        info.msg2.size as __srcc_ffi_int,
        info.msg2.data,
    );

    libc::putchar("\n"[0]);
    libc::abort();
}

/// Helpers to format assertion messages.
export struct __src_assert_msg_buf {
    i8^ data;
    int size;
    int capacity;
}

export proc __src_append_int (inout __src_assert_msg_buf into, copy int value) nomangle {
    // 0 is a special case.
    if value == 0 then {
        __src_append_str(into, '0');
        return;
    }

    // For everything else, we need a tempoary buffer.
    i8[int.bits] tmp;
    int bits_used = 0;

    // Remember whether this was negative.
    bool negative = value < 0;
    if negative then value = -value;

    // Append the digits.
    while value != 0 {
        tmp[bits_used] = (value % 10) as i8 + '0'[0];
        value /= 10;
        bits_used++;
    }

    // If the value was negative, add a minus sign.
    if negative then __src_append_str(into, '-');

    // Reverse the digits.
    for i in 0..<bits_used/2 {
        int j = bits_used - i - 1;
        tmp[i] >< tmp[j];
    }

    // And append them.
    __src_append_str(into, (&tmp, bits_used));
}

export proc __src_append_str (inout __src_assert_msg_buf into, i8[] str) nomangle {
    if into.size + str.size >= into.capacity return;
    __srcc_memcpy(__srcc_ptradd(into.data, into.size), str.data, str.size);
    into.size += str.size;
}


/// Declare our own initialiser so we can call it.
///
/// Unlike other modules, the runtime is not initialised when it is
/// imported (this is mostly an optimisation to avoid having to call
/// its initialiser in *every* module, and also because we might not
/// have a runtime); this means that we need to initialise ourselves.
proc \(__src_static_init.__src_runtime) extern nomangle;

/// Entry point called by the C runtime.
export proc __src_runtime_entry(
    __srcc_ffi_int argc,
    __srcc_ffi_char^^ argv,
) native {
    \(__src_static_init.__src_runtime)();
    __src_main();
}
