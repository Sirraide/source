// This grammar defines how Source is *parsed*; it does not convey
// any information about the semantics of the language. Operator
// precedence is also omitted.

<file> ::= <preamble> <stmts>

// ============================================================================
//  Preamble
// ============================================================================
//  Notes:
//
//   - IMPORT is a full keyword so the lexer knows the token after it is a
//     cxx-header-name if it starts w/ '<'.
//
//   - "program" and "module" are not because they are literally only keywords
//     if they’re the first token in the program.
//
<preamble>        ::= <header> { <import> }
<header>          ::= ( "program" | "module" ) <module-name> ";"
<import>          ::= IMPORT <import-name> AS ( IDENT | "* ) ";"
<module-name>     ::= IDENT
<import-name>     ::= IDENT | CXX-HEADER-NAME { "," CXX-HEADER-NAME } [ "," ]

// ============================================================================
//  Statements
// ============================================================================
// This is a very convoluted way of specifying ‘a semicolon-separated sequence
// of <stmt>s, except that no semicolons are required after '}'.
<stmts> ::= { <stmt> } [ <expr> ]
<stmt>  ::= <expr-braces>
          | <expr-no-braces> ";"
          | <decl>
          | <stmt-defer>
          | <stmt-while>
          | <stmt-for>
          | ";"

<stmt-defer>   ::= DEFER <stmt>
<stmt-while>   ::= WHILE <expr> [ DO ] <stmt>
<if-stmt-body> ::= [ THEN ] <stmt>

// Note: The support for trailing commas here was accidental, but I don’t really have a problem w/ it.
<stmt-for> ::= FOR [ <for-vars> IN ] <expr> { "," <expr> } [ "," ] DO <stmt>
<for-vars> ::= <idents> | ENUM IDENT [ "," <idents> ]
<idents>   ::= IDENT { "," IDENT } [ "," ]

// ============================================================================
//  Expressions
// ============================================================================
// Note: <expr-quote> may or may not have braces.
<expr>           ::= <expr-braces> | <expr-no-braces>
<expr-braces>    ::= <expr-block> | <expr-match> | <expr-quote>
<expr-no-braces> ::= <expr-assert>
                   | <expr-if>
                   | <expr-binary>
                   | <expr-break>
                   | <expr-call>
                   | <expr-continue>
                   | <expr-decl-ref>
                   | <expr-eval>
                   | <expr-inject>
                   | <expr-lit>
                   | <expr-loop>
                   | <expr-macro-call>
                   | <expr-member>
                   | <expr-nil>
                   | <expr-paren>
                   | <expr-prefix>
                   | <expr-quote>
                   | <expr-return>
                   | <expr-subscript>
                   | <expr-tuple>
                   | <expr-postfix>
                   | <expr-with>
                   | <type>

<expr-assert>     ::= [ "#" ] ASSERT <expr> [ "," <expr> ]
<expr-binary>     ::= <expr> <binary> <expr>
<expr-block>      ::= "{" <stmts>  "}"
<expr-break>      ::= BREAK
<expr-call>       ::= <expr> "(" [ <call-args> ] ")"
<expr-macro-call> ::= "#" <expr-decl-ref> "(" [ <macro-args> ] ")"
<expr-continue>   ::= CONTINUE
<expr-decl-ref>   ::= IDENT [ "::" <expr-decl-ref> ]
<expr-eval>       ::= EVAL ( <sub-stmt> )
<expr-inject>     ::= "#" INJECT "(" <expr> ")"
<expr-if>         ::= [ "#" ] IF <expr> <if-expr-body> { [ "#" ] ELIF <expr> <if-expr-body> } [ [ "#" ] ELSE <if-expr-body> ]
<expr-lit>        ::= STRING-LITERAL | INTEGER | TRUE | FALSE
<expr-loop>       ::= LOOP [ <sub-stmt> ]
<expr-match>      ::= MATCH [ <expr> ] [ "->" <type> ] "{" <match-case> [ ";" ] "}"
<expr-member>     ::= <expr> "." IDENT
<expr-nil>        ::= NIL
<expr-paren>      ::= "(" <expr> ")"
<expr-prefix>     ::= <prefix> <expr>
<expr-quote>      ::= QUOTE ( "{" macro-body "}" | "(" macro-body ")" )
<expr-return>     ::= RETURN [ <expr> ]
<expr-subscript>  ::= <expr> "[" <expr> "]" // Only one argument for now.
<expr-tuple>      ::= "(" <expr> { "," <expr> } [ "," ] ")"
<expr-postfix>    ::= <expr> ( "++" | "--" )
<stmt-with>       ::= WITH <expr> [ DO ] <sub-stmt>

<call-args> ::= <expr> { "," <expr> } [ "," ]
<macro-args> ::= macro-body { "," macro-body } [ "," ]
<macro-body> ::= { <tokens> | <unquote> }
<sub-stmt> ::= <expr> | <stmt> // Essentially '<stmt>', but handling the semicolon is left to the caller.
<prefix> ::= "-" | "+" | NOT | "~" | "&" | "^" | INLINE
<if-expr-body> ::= [ THEN ] ( <sub-stmt> )
<unquote> ::= "$" "(" <expr> ")"
<binary> ::= // TODO: list all binary operators here.

<match-case> ::= <pattern> ":" <stmt>
<pattern>    ::= <expr>

// ============================================================================
//  Declarations
// ============================================================================
<decl>        ::= <decl-proc> | <decl-var> | <decl-struct> | EXPORT <decl>
<decl-var>    ::= [ STATIC ] <type> IDENT [ "=" <expr> ]
<decl-proc>   ::= <signature> <proc-body>
<decl-struct> ::= STRUCT IDENT "{" { <type> IDENT ";" } "}"
<signature>   ::= PROC [ IDENT ] [ <proc-args> ] <proc-attrs> [ "->" <type> ] [ <proc-where> ]
<proc-args>   ::= "(" [ <param-decl> { "," <param-decl> } [ "," ] ] ")"
<proc-attrs>  ::= { "native" | "extern" | "nomangle" | "variadic" }
<proc-where>  ::= WHERE <expr>
<proc-body>   ::= <expr-block> | "=" <expr-braces> | "=" <expr-no-braces> ";" | ";"
<param-decl>  ::= [ WITH ] [ <intent> ] <param-rest>
<param-rest>  ::= <type> [ "..." ] [ IDENT ] | <signature>
<intent>      ::= IN | OUT | INOUT | COPY

// ============================================================================
//  Types
// ============================================================================
<type> ::= <type-prim>
         | TEMPLATE-TYPE
         | <signature>
         | <type-qualified>
         | <type-range>
         | <type-typeof>
         | <expr-decl-ref> // Named type
         | <expr-tuple>    // Tuple type
         | <expr-binary>   // Array type (parsed as subscript expression)
         | <expr-call>     // Function that returns a type
         | "(" <expr> ")"  // Any expression in parens can be treated as a type
         | <expr>          // In type-only contexts

<type-qualified> ::= <type> { <qualifier> }
<type-range> ::= RANGE "<" <type> ">"
<type-typeof> ::= TYPEOF "(" <expr> ")"
<qualifier> ::= "[" "]" | "^" | "?"
<type-prim> ::= BOOL | INT | TREE | TYPE | VOID | VAR | INTEGER_TYPE

// ============================================================================
//  Pragmas
// ============================================================================
// These are handled by the lexer and may thus appear anywhere.
<pragma> ::= <pragma-include>
<pragma-include> ::= PRAGMA "include" STRING-LITERAL
