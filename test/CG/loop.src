// R %srcc --ir -fno-overflow-checks %s
program test;

proc a extern -> int;

proc d {
    loop { a(); }
}

proc e { loop a(); }
proc f { loop 4; }
proc g { loop; }
proc h = a() + loop;

var x = if 1 == 1 then 3 else loop;

// * proc __src_assert_fail (ptr) external fastcc;
// +
// + proc __src_int_arith_error (ptr) external fastcc;
// +
// + proc __src_main external fastcc {
// +     #0 = 8, align 8
// +
// + entry:
// +     store #0, i64 3, align 8
// +     ret
// + }
// +
// + proc _S1dFvE private fastcc {
// + entry:
// +     br bb1
// +
// + bb1:
// +     %0 = call fastcc i64 _S1aFiE()
// +     br bb1
// + }
// +
// + proc _S1aFiE external fastcc -> i64;
// +
// + proc _S1eFvE private fastcc {
// + entry:
// +     br bb1
// +
// + bb1:
// +     %0 = call fastcc i64 _S1aFiE()
// +     br bb1
// + }
// +
// + proc _S1fFvE private fastcc {
// + entry:
// +     br bb1
// +
// + bb1:
// +     br bb1
// + }
// +
// + proc _S1gFvE private fastcc {
// + entry:
// +     br bb1
// +
// + bb1:
// +     br bb1
// + }
// +
// + proc _S1hFiE private fastcc -> i64 {
// + entry:
// +     %0 = call fastcc i64 _S1aFiE()
// +     br bb1
// +
// + bb1:
// +     br bb1
// + }
