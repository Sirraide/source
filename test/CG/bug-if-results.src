// R %srcc --ir --target x86_64-unknown-linux -foverflow-checks=false %s
program test;

// Check that we donâ€™t try to add arguments to the join block
// just because emitting the then block happens to yield values.

proc x (int) extern;

proc f (bool b) {
    if b {
        x(1);
        1;
    } else {
        x(2);
    }

    if b {
        x(3);
    } else {
        x(4);
        1;
    }
}

// * proc __src_main external ccc {
// + entry:
// +     ret
// + }
// +
// + proc _S1fFvbE.1 (i1 %0 zeroext) private ccc {
// +     #0 = 1, align 1
// +
// + entry:
// +     %1 = sext i1 %0 to i8
// +     store #0, i8 %1, align 1
// +     %2 = load i8, #0, align 1
// +     %3 = trunc i8 %2 to i1
// +     br %3 to bb1 else bb2
// +
// + bb1:
// +     call ccc void x(i64 1)
// +     br bb3
// +
// + bb2:
// +     call ccc void x(i64 2)
// +     br bb3
// +
// + bb3:
// +     %4 = load i8, #0, align 1
// +     %5 = trunc i8 %4 to i1
// +     br %5 to bb4 else bb5
// +
// + bb4:
// +     call ccc void x(i64 3)
// +     br bb6
// +
// + bb5:
// +     call ccc void x(i64 4)
// +     br bb6
// +
// + bb6:
// +     ret
// + }
// +
// + proc x (i64) external ccc;
