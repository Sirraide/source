// R %srcc --ir --target x86_64-unknown-linux -foverflow-checks=false %s
program test;

proc f(int) extern;
proc g() extern;
proc h() extern;
proc b() extern -> bool;

proc p1 {
    loop {
        h();
        break;
        g();
    }
}

proc p2 {
    loop {
        continue;
        g();
    }
}

proc p3 {
    for i in 1..<10 {
        continue;
        g();
    }
}

proc p4 {
    for i in 1..<10 {
        h();
        break;
        g();
    }
}

proc p5 {
    while true {
        h();
        break;
        g();
    }
}

proc p6 {
    while true {
        continue;
        g();
    }
}

proc p7 {
    for i in 1..<10 {
        for j in 1..<10 {
            if i == j break;
            if j == 5 continue;
            g();
        }
        if i == 5 continue;
        h();
    }
}

proc p8 {
    loop {
        f(1);
        defer g();
        if b() break;
        defer h();
        f(2);
    }
}

proc p9 {
    loop {
        f(1);
        defer g();
        if b() continue;
        defer h();
        f(2);
    }
}

proc p10 {
    while b() {
        f(1);
        defer g();
        if b() break;
        defer h();
        f(2);
    }
}

proc p11 {
    while b() {
        f(1);
        defer g();
        if b() continue;
        defer h();
        f(2);
    }
}

proc p12 {
    for "123" {
        f(1);
        defer g();
        if b() break;
        defer h();
        f(2);
    }
}

proc p13 {
    for "123" {
        f(1);
        defer g();
        if b() continue;
        defer h();
        f(2);
    }
}

// * @0 = "123\00"
// +
// + proc __src_main norecurse external ccc {
// + entry:
// +     ret
// + }
// +
// + proc _S2p1FvE.1 private ccc {
// + entry:
// +     call ccc void h()
// +     ret
// + }
// +
// + proc h external ccc;
// +
// + proc g external ccc;
// +
// + proc _S2p2FvE.2 private ccc {
// + entry:
// +     br bb1
// +
// + bb1:
// +     br bb1
// + }
// +
// + proc _S2p3FvE.3 private ccc {
// + entry:
// +     br bb1(1)
// +
// + bb1(i64 %0):
// +     %1 = icmp ne i64 %0, 10
// +     br %1 to bb2 else bb3
// +
// + bb2:
// +     %2 = add i64 %0, 1
// +     br bb1(%2)
// +
// + bb3:
// +     ret
// + }
// +
// + proc _S2p4FvE.4 private ccc {
// + entry:
// +     call ccc void h()
// +     ret
// + }
// +
// + proc _S2p5FvE.5 private ccc {
// + entry:
// +     call ccc void h()
// +     ret
// + }
// +
// + proc _S2p6FvE.6 private ccc {
// + entry:
// +     br bb1
// +
// + bb1:
// +     br bb1
// + }
// +
// + proc _S2p7FvE.7 private ccc {
// + entry:
// +     br bb1(1)
// +
// + bb1(i64 %0):
// +     %1 = icmp ne i64 %0, 10
// +     br %1 to bb2(1) else bb10
// +
// + bb2(i64 %2):
// +     %3 = icmp ne i64 %2, 10
// +     br %3 to bb3 else bb7
// +
// + bb3:
// +     %4 = icmp eq i64 %0, %2
// +     br %4 to bb7 else bb4
// +
// + bb4:
// +     %5 = icmp eq i64 %2, 5
// +     br %5 to bb6 else bb5
// +
// + bb5:
// +     call ccc void g()
// +     br bb6
// +
// + bb6:
// +     %6 = add i64 %2, 1
// +     br bb2(%6)
// +
// + bb7:
// +     %7 = icmp eq i64 %0, 5
// +     br %7 to bb9 else bb8
// +
// + bb8:
// +     call ccc void h()
// +     br bb9
// +
// + bb9:
// +     %8 = add i64 %0, 1
// +     br bb1(%8)
// +
// + bb10:
// +     ret
// + }
// +
// + proc _S2p8FvE.8 private ccc {
// + entry:
// +     br bb1
// +
// + bb1:
// +     call ccc void f(i64 1)
// +     %0 = call ccc zeroext i1 b()
// +     br %0 to bb2 else bb3
// +
// + bb2:
// +     call ccc void g()
// +     ret
// +
// + bb3:
// +     call ccc void f(i64 2)
// +     call ccc void h()
// +     call ccc void g()
// +     br bb1
// + }
// +
// + proc f (i64) external ccc;
// +
// + proc b external ccc -> i1 zeroext;
// +
// + proc _S2p9FvE.9 private ccc {
// + entry:
// +     br bb1
// +
// + bb1:
// +     call ccc void f(i64 1)
// +     %0 = call ccc zeroext i1 b()
// +     br %0 to bb2 else bb3
// +
// + bb2:
// +     call ccc void g()
// +     br bb1
// +
// + bb3:
// +     call ccc void f(i64 2)
// +     call ccc void h()
// +     call ccc void g()
// +     br bb1
// + }
// +
// + proc _S3p10FvE.10 private ccc {
// + entry:
// +     br bb1
// +
// + bb1:
// +     %0 = call ccc zeroext i1 b()
// +     br %0 to bb2 else bb5
// +
// + bb2:
// +     call ccc void f(i64 1)
// +     %1 = call ccc zeroext i1 b()
// +     br %1 to bb3 else bb4
// +
// + bb3:
// +     call ccc void g()
// +     br bb5
// +
// + bb4:
// +     call ccc void f(i64 2)
// +     call ccc void h()
// +     call ccc void g()
// +     br bb1
// +
// + bb5:
// +     ret
// + }
// +
// + proc _S3p11FvE.11 private ccc {
// + entry:
// +     br bb1
// +
// + bb1:
// +     %0 = call ccc zeroext i1 b()
// +     br %0 to bb2 else bb5
// +
// + bb2:
// +     call ccc void f(i64 1)
// +     %1 = call ccc zeroext i1 b()
// +     br %1 to bb3 else bb4
// +
// + bb3:
// +     call ccc void g()
// +     br bb1
// +
// + bb4:
// +     call ccc void f(i64 2)
// +     call ccc void h()
// +     call ccc void g()
// +     br bb1
// +
// + bb5:
// +     ret
// + }
// +
// + proc _S3p12FvE.12 private ccc {
// + entry:
// +     %0 = ptradd @0, 3
// +     br bb1(@0)
// +
// + bb1(ptr %1):
// +     %2 = cmp ne ptr %1, %0
// +     br %2 to bb2 else bb5
// +
// + bb2:
// +     call ccc void f(i64 1)
// +     %3 = call ccc zeroext i1 b()
// +     br %3 to bb3 else bb4
// +
// + bb3:
// +     call ccc void g()
// +     br bb5
// +
// + bb4:
// +     call ccc void f(i64 2)
// +     call ccc void h()
// +     call ccc void g()
// +     %4 = ptradd %1, 1
// +     br bb1(%4)
// +
// + bb5:
// +     ret
// + }
// +
// + proc _S3p13FvE.13 private ccc {
// + entry:
// +     %0 = ptradd @0, 3
// +     br bb1(@0)
// +
// + bb1(ptr %1):
// +     %2 = cmp ne ptr %1, %0
// +     br %2 to bb2 else bb6
// +
// + bb2:
// +     call ccc void f(i64 1)
// +     %3 = call ccc zeroext i1 b()
// +     br %3 to bb3 else bb4
// +
// + bb3:
// +     call ccc void g()
// +     br bb5
// +
// + bb4:
// +     call ccc void f(i64 2)
// +     call ccc void h()
// +     call ccc void g()
// +     br bb5
// +
// + bb5:
// +     %4 = ptradd %1, 1
// +     br bb1(%4)
// +
// + bb6:
// +     ret
// + }
