// R      %srcc --ir   --target x86_64-unknown-linux %s
// R[//L] %srcc --llvm --target x86_64-unknown-linux %s
program test;

proc a {
    int i;
    int^? pi;
    pi = ();
    pi = &i;
}

proc b (bool b) {
    int i;
    int j;
    int^? pi;
    if b then pi = &i;
    else pi = &j;
    ^pi = 42;
}

proc c (int^? x) = x;

proc d {
    int i;
    int j;
    int^? p1 = ((&(i)));
    int^? p2 = if true then p1 else p1;
    int^? p3 = if true then &i else &j;
}

proc e {
    int i;
    int^? p1 = &i;
    int^? p2 = p1;
    ^p2 = 42;
}

// * proc __src_main norecurse external ccc {
// + entry:
// +     ret
// + }
// +
// + proc _S1aFvE.1 private ccc {
// +     #0 = 8, align 8
// +     #1 = 8, align 8
// +
// + entry:
// +     store #0, i64 0, align 8
// +     store #1, ptr nil, align 8
// +     disengage #1
// +     store #1, ptr nil, align 8
// +     disengage #1
// +     store #1, ptr #0, align 8
// +     engage #1
// +     ret
// + }
// +
// + proc _S1bFvbE.2 (i1 %0 noundef zeroext) private ccc {
// +     #0 = 1, align 1
// +     #1 = 8, align 8
// +     #2 = 8, align 8
// +     #3 = 8, align 8
// +
// + entry:
// +     %1 = sext i1 %0 to i8
// +     store #0, i8 %1, align 1
// +     store #1, i64 0, align 8
// +     store #2, i64 0, align 8
// +     store #3, ptr nil, align 8
// +     disengage #3
// +     %2 = load i8, #0, align 1
// +     %3 = trunc i8 %2 to i1
// +     br %3 to bb1 else bb2
// +
// + bb1:
// +     store #3, ptr #1, align 8
// +     engage #3
// +     br bb3
// +
// + bb2:
// +     store #3, ptr #2, align 8
// +     engage #3
// +     br bb3
// +
// + bb3:
// +     unwrap #3
// +     %4 = load ptr, #3, align 8
// +     store %4, i64 42, align 8
// +     ret
// + }
// +
// + proc _S1cFORiORiE.3 (ptr %0 align 8 dereferenceable 8 noundef) private ccc -> ptr {
// +     #0 = 8, align 8
// +
// + entry:
// +     store #0, ptr %0, align 8
// +     %1 = load ptr, #0, align 8
// +     ret ptr %1
// + }
// +
// + proc _S1dFvE.4 private ccc {
// +     #0 = 8, align 8
// +     #1 = 8, align 8
// +     #2 = 8, align 8
// +     #3 = 8, align 8
// +     #4 = 8, align 8
// +
// + entry:
// +     store #0, i64 0, align 8
// +     store #1, i64 0, align 8
// +     store #2, ptr #0, align 8
// +     engage #2
// +     %0 = load ptr, #2, align 8
// +     store #3, ptr %0, align 8
// +     engage #3 <- #2
// +     store #4, ptr #0, align 8
// +     engage #4
// +     ret
// + }
// +
// + proc _S1eFvE.5 private ccc {
// +     #0 = 8, align 8
// +     #1 = 8, align 8
// +     #2 = 8, align 8
// +
// + entry:
// +     store #0, i64 0, align 8
// +     store #1, ptr #0, align 8
// +     engage #1
// +     %0 = load ptr, #1, align 8
// +     store #2, ptr %0, align 8
// +     engage #2 <- #1
// +     unwrap #2
// +     %1 = load ptr, #2, align 8
// +     store %1, i64 42, align 8
// +     ret
// + }

//L * ; ModuleID = 'test'
//L + source_filename = "test"
//L + target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"
//L + target triple = "x86_64-unknown-linux"
//L +
//L + ; Function Attrs: norecurse nounwind
//L + define void @__src_main() #0 {
//L +   ret void
//L + }
//L +
//L + ; Function Attrs: nounwind
//L + define private void @_S1aFvE.1() #1 {
//L +   %1 = alloca i8, i64 8, align 8
//L +   %2 = alloca i8, i64 8, align 8
//L +   store i64 0, ptr %1, align 8
//L +   store ptr null, ptr %2, align 8
//L +   store ptr null, ptr %2, align 8
//L +   store ptr %1, ptr %2, align 8
//L +   ret void
//L + }
//L +
//L + ; Function Attrs: nounwind
//L + define private void @_S1bFvbE.2(i1 noundef zeroext %0) #1 {
//L +   %2 = alloca i8, i64 1, align 1
//L +   %3 = alloca i8, i64 8, align 8
//L +   %4 = alloca i8, i64 8, align 8
//L +   %5 = alloca i8, i64 8, align 8
//L +   %6 = sext i1 %0 to i8
//L +   store i8 %6, ptr %2, align 1
//L +   store i64 0, ptr %3, align 8
//L +   store i64 0, ptr %4, align 8
//L +   store ptr null, ptr %5, align 8
//L +   %7 = load i8, ptr %2, align 1
//L +   %8 = trunc i8 %7 to i1
//L +   br i1 %8, label %9, label %10
//L +
//L + 9:                                                ; preds = %1
//L +   store ptr %3, ptr %5, align 8
//L +   br label %11
//L +
//L + 10:                                               ; preds = %1
//L +   store ptr %4, ptr %5, align 8
//L +   br label %11
//L +
//L + 11:                                               ; preds = %9, %10
//L +   %12 = load ptr, ptr %5, align 8
//L +   store i64 42, ptr %12, align 8
//L +   ret void
//L + }
//L +
//L + ; Function Attrs: nounwind
//L + define private ptr @_S1cFORiORiE.3(ptr noundef align 8 dereferenceable(8) %0) #1 {
//L +   %2 = alloca i8, i64 8, align 8
//L +   store ptr %0, ptr %2, align 8
//L +   %3 = load ptr, ptr %2, align 8
//L +   ret ptr %3
//L + }
//L +
//L + ; Function Attrs: nounwind
//L + define private void @_S1dFvE.4() #1 {
//L +   %1 = alloca i8, i64 8, align 8
//L +   %2 = alloca i8, i64 8, align 8
//L +   %3 = alloca i8, i64 8, align 8
//L +   %4 = alloca i8, i64 8, align 8
//L +   %5 = alloca i8, i64 8, align 8
//L +   store i64 0, ptr %1, align 8
//L +   store i64 0, ptr %2, align 8
//L +   store ptr %1, ptr %3, align 8
//L +   %6 = load ptr, ptr %3, align 8
//L +   store ptr %6, ptr %4, align 8
//L +   store ptr %1, ptr %5, align 8
//L +   ret void
//L + }
//L +
//L + ; Function Attrs: nounwind
//L + define private void @_S1eFvE.5() #1 {
//L +   %1 = alloca i8, i64 8, align 8
//L +   %2 = alloca i8, i64 8, align 8
//L +   %3 = alloca i8, i64 8, align 8
//L +   store i64 0, ptr %1, align 8
//L +   store ptr %1, ptr %2, align 8
//L +   %4 = load ptr, ptr %2, align 8
//L +   store ptr %4, ptr %3, align 8
//L +   %5 = load ptr, ptr %3, align 8
//L +   store i64 42, ptr %5, align 8
//L +   ret void
//L + }
//L +
//L + attributes #0 = { norecurse nounwind }
//L + attributes #1 = { nounwind }
//L +
//L + !llvm.module.flags = !{!0}
//L +
//L + !0 = !{i32 2, !"Debug Info Version", i32 3}
