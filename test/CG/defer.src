// R %srcc --ir --target x86_64-unknown-linux %s
program test;

proc h() extern native -> bool;
proc g(int i) extern native;
proc exit() extern native -> noreturn;
proc q(int i) extern native;

proc f1 {
    defer g(4);
    defer g(3);
    defer g(2);
    defer g(1);
}

proc f2 {
    defer g(5);
    {
        defer g(4);
        {
            defer g(2);
            defer g(1);
        };
        g(3);
    };
}

proc f3 (bool ret) {
    defer g(2);
    if ret return;
    defer g(1);
}

proc f4 {
    return;
    defer g(1);
}

proc f5 {
    if h() defer g(1);
    if h() then defer g(2);
    while h() defer g(3);
    while h() do defer g(4);
    for i in 1..=10 do defer g(5);
    match { _: defer g(6); };
    match 1 { _: defer g(7); };
    loop defer g(8);
}

proc f6 {
    defer if h() then g(2);
    defer if h() then g(1);
}

proc f7 {
  defer g(5);
  defer defer g(4);
  defer defer defer g(3);
  defer defer defer defer g(2);
  g(1);
}

proc f8 {
    defer g(1);
    exit();
}

proc f9 {
    defer {
        defer g(5);
        defer g(4);
        defer {
            defer g(3);
            defer {
                defer g(2);
                defer g(1);
            }
        }
    }
}

proc f10 {
    if h() return;
    defer g(4);
    {
        if h() return;
        defer g(3);
        q(1);
        {
            if h() return;
            defer g(2);
            q(2);
            {
                if h() return;
                defer g(1);
                q(3);
            };
            q(4);
        };
        q(5);
    };
    q(6);
}

// * proc __src_main external fastcc {
// + entry:
// +     ret
// + }
// +
// + proc _S2f1FvE private fastcc {
// + entry:
// +     call ccc void g(i64 1)
// +     call ccc void g(i64 2)
// +     call ccc void g(i64 3)
// +     call ccc void g(i64 4)
// +     ret
// + }
// +
// + proc g (i64) external ccc;
// +
// + proc _S2f2FvE private fastcc {
// + entry:
// +     call ccc void g(i64 1)
// +     call ccc void g(i64 2)
// +     call ccc void g(i64 3)
// +     call ccc void g(i64 4)
// +     call ccc void g(i64 5)
// +     ret
// + }
// +
// + proc _S2f3FvbE (i1 %0 zeroext) private fastcc {
// +     #0 = 1, align 1
// +
// + entry:
// +     %1 = sext i1 %0 to i8
// +     store #0, i8 %1, align 1
// +     %2 = load i8, #0, align 1
// +     %3 = trunc i8 %2 to i1
// +     br %3 to bb1 else bb2
// +
// + bb1:
// +     call ccc void g(i64 2)
// +     ret
// +
// + bb2:
// +     call ccc void g(i64 1)
// +     call ccc void g(i64 2)
// +     ret
// + }
// +
// + proc _S2f4FvE private fastcc {
// + entry:
// +     ret
// + }
// +
// + proc _S2f5FvE private fastcc {
// + entry:
// +     %0 = call ccc zeroext i1 h()
// +     br %0 to bb1 else bb2
// +
// + bb1:
// +     call ccc void g(i64 1)
// +     br bb2
// +
// + bb2:
// +     %1 = call ccc zeroext i1 h()
// +     br %1 to bb3 else bb4
// +
// + bb3:
// +     call ccc void g(i64 2)
// +     br bb4
// +
// + bb4:
// +     %2 = call ccc zeroext i1 h()
// +     br %2 to bb5 else bb6
// +
// + bb5:
// +     call ccc void g(i64 3)
// +     br bb4
// +
// + bb6:
// +     %3 = call ccc zeroext i1 h()
// +     br %3 to bb7 else bb8(1)
// +
// + bb7:
// +     call ccc void g(i64 4)
// +     br bb6
// +
// + bb8(i64 %4):
// +     %5 = icmp ne i64 %4, 11
// +     br %5 to bb9 else bb10
// +
// + bb9:
// +     call ccc void g(i64 5)
// +     %6 = add i64 %4, 1
// +     br bb8(%6)
// +
// + bb10:
// +     call ccc void g(i64 6)
// +     call ccc void g(i64 7)
// +     br bb11
// +
// + bb11:
// +     call ccc void g(i64 8)
// +     br bb11
// + }
// +
// + proc h external ccc -> i1 zeroext;
// +
// + proc _S2f6FvE private fastcc {
// + entry:
// +     %0 = call ccc zeroext i1 h()
// +     br %0 to bb1 else bb2
// +
// + bb1:
// +     call ccc void g(i64 1)
// +     br bb2
// +
// + bb2:
// +     %1 = call ccc zeroext i1 h()
// +     br %1 to bb3 else bb4
// +
// + bb3:
// +     call ccc void g(i64 2)
// +     br bb4
// +
// + bb4:
// +     ret
// + }
// +
// + proc _S2f7FvE private fastcc {
// + entry:
// +     call ccc void g(i64 1)
// +     call ccc void g(i64 2)
// +     call ccc void g(i64 3)
// +     call ccc void g(i64 4)
// +     call ccc void g(i64 5)
// +     ret
// + }
// +
// + proc _S2f8FvE private fastcc {
// + entry:
// +     call ccc void exit()
// +     unreachable
// + }
// +
// + proc exit noreturn external ccc;
// +
// + proc _S2f9FvE private fastcc {
// + entry:
// +     call ccc void g(i64 1)
// +     call ccc void g(i64 2)
// +     call ccc void g(i64 3)
// +     call ccc void g(i64 4)
// +     call ccc void g(i64 5)
// +     ret
// + }
// +
// + proc _S3f10FvE private fastcc {
// + entry:
// +     %0 = call ccc zeroext i1 h()
// +     br %0 to bb1 else bb2
// +
// + bb1:
// +     ret
// +
// + bb2:
// +     %1 = call ccc zeroext i1 h()
// +     br %1 to bb3 else bb4
// +
// + bb3:
// +     call ccc void g(i64 4)
// +     ret
// +
// + bb4:
// +     call ccc void q(i64 1)
// +     %2 = call ccc zeroext i1 h()
// +     br %2 to bb5 else bb6
// +
// + bb5:
// +     call ccc void g(i64 3)
// +     call ccc void g(i64 4)
// +     ret
// +
// + bb6:
// +     call ccc void q(i64 2)
// +     %3 = call ccc zeroext i1 h()
// +     br %3 to bb7 else bb8
// +
// + bb7:
// +     call ccc void g(i64 2)
// +     call ccc void g(i64 3)
// +     call ccc void g(i64 4)
// +     ret
// +
// + bb8:
// +     call ccc void q(i64 3)
// +     call ccc void g(i64 1)
// +     call ccc void q(i64 4)
// +     call ccc void g(i64 2)
// +     call ccc void q(i64 5)
// +     call ccc void g(i64 3)
// +     call ccc void q(i64 6)
// +     call ccc void g(i64 4)
// +     ret
// + }
// +
// + proc q (i64) external ccc;
