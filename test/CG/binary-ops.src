// R %srcc --ir --short-filenames --target x86_64-unknown-linux %s
program test;

proc sink (in int) {}
proc sink (in bool) {}

proc arith_checked (in int a, in int b) {
    sink(a + b);
    sink(a - b);
    sink(a * b);

    sink(a / b);
    sink(a % b);
    sink(a :/ b);
    sink(a :% b);

    sink(a << b);
    sink(a <<< b);
}

proc arith (in int a, in int b) {
    sink(a +~ b);
    sink(a -~ b);
    sink(a *~ b);

    sink(a >> b);
    sink(a >>> b);

    sink(a & b);
    sink(a | b);

    sink(a < b);
    sink(a <= b);
    sink(a > b);
    sink(a >= b);

    sink(a <: b);
    sink(a <=: b);
    sink(a :> b);
    sink(a :>= b);

    sink(a == b);
    sink(a != b);
}

// * @0 = "+\00"
// + @1 = "integer overflow\00"
// + @2 = "binary-ops.src\00"
// + @3 = "-\00"
// + @4 = "*\00"
// + @5 = "/\00"
// + @6 = "division by zero\00"
// + @7 = "%\00"
// + @8 = ":/\00"
// + @9 = ":%\00"
// + @10 = "<<\00"
// + @11 = "shift amount exceeds bit width\00"
// + @12 = "<<<\00"
// +
// + proc __src_main external ccc {
// + entry:
// +     ret
// + }
// +
// + proc _S4sinkFvxiE (i64 %0) private ccc {
// +     #0 = 8, align 8
// +
// + entry:
// +     store #0, i64 %0, align 8
// +     ret
// + }
// +
// + proc _S4sinkFvxbE (i1 %0 zeroext) private ccc {
// +     #0 = 1, align 1
// +
// + entry:
// +     %1 = sext i1 %0 to i8
// +     store #0, i8 %1, align 1
// +     ret
// + }
// +
// + proc _S13arith_checkedFvxixiE (i64 %0, i64 %1) private ccc {
// +     #0 = 8, align 8
// +     #1 = 8, align 8
// +     #2 = 80, align 8
// +
// + entry:
// +     store #0, i64 %0, align 8
// +     store #1, i64 %1, align 8
// +     %2 = load i64, #0, align 8
// +     %3 = load i64, #1, align 8
// +     %4 = sadd ov i64 %2, %3
// +     br %4:1 to bb1 else bb2
// +
// + bb1:
// +     abort at loc("binary-ops.src":8:10) arithmetic(ptr #2)
// +
// + bb2:
// +     call ccc void _S4sinkFvxiE(i64 %4:0)
// +     %14 = load i64, #0, align 8
// +     %15 = load i64, #1, align 8
// +     %16 = ssub ov i64 %14, %15
// +     br %16:1 to bb3 else bb4
// +
// + bb3:
// +     abort at loc("binary-ops.src":9:10) arithmetic(ptr #2)
// +
// + bb4:
// +     call ccc void _S4sinkFvxiE(i64 %16:0)
// +     %26 = load i64, #0, align 8
// +     %27 = load i64, #1, align 8
// +     %28 = smul ov i64 %26, %27
// +     br %28:1 to bb5 else bb6
// +
// + bb5:
// +     abort at loc("binary-ops.src":10:10) arithmetic(ptr #2)
// +
// + bb6:
// +     call ccc void _S4sinkFvxiE(i64 %28:0)
// +     %38 = load i64, #0, align 8
// +     %39 = load i64, #1, align 8
// +     %40 = icmp eq i64 %39, 0
// +     br %40 to bb7 else bb8
// +
// + bb7:
// +     abort at loc("binary-ops.src":12:10) arithmetic(ptr #2)
// +
// + bb8:
// +     %50 = icmp eq i64 %38, -9223372036854775808
// +     %51 = icmp eq i64 %39, -1
// +     %52 = and i1 %50, %51
// +     br %52 to bb9 else bb10
// +
// + bb9:
// +     abort at loc("binary-ops.src":12:10) arithmetic(ptr #2)
// +
// + bb10:
// +     %62 = sdiv i64 %38, %39
// +     call ccc void _S4sinkFvxiE(i64 %62)
// +     %63 = load i64, #0, align 8
// +     %64 = load i64, #1, align 8
// +     %65 = icmp eq i64 %64, 0
// +     br %65 to bb11 else bb12
// +
// + bb11:
// +     abort at loc("binary-ops.src":13:10) arithmetic(ptr #2)
// +
// + bb12:
// +     %75 = icmp eq i64 %63, -9223372036854775808
// +     %76 = icmp eq i64 %64, -1
// +     %77 = and i1 %75, %76
// +     br %77 to bb13 else bb14
// +
// + bb13:
// +     abort at loc("binary-ops.src":13:10) arithmetic(ptr #2)
// +
// + bb14:
// +     %87 = srem i64 %63, %64
// +     call ccc void _S4sinkFvxiE(i64 %87)
// +     %88 = load i64, #0, align 8
// +     %89 = load i64, #1, align 8
// +     %90 = icmp eq i64 %89, 0
// +     br %90 to bb15 else bb16
// +
// + bb15:
// +     abort at loc("binary-ops.src":14:10) arithmetic(ptr #2)
// +
// + bb16:
// +     %100 = udiv i64 %88, %89
// +     call ccc void _S4sinkFvxiE(i64 %100)
// +     %101 = load i64, #0, align 8
// +     %102 = load i64, #1, align 8
// +     %103 = icmp eq i64 %102, 0
// +     br %103 to bb17 else bb18
// +
// + bb17:
// +     abort at loc("binary-ops.src":15:10) arithmetic(ptr #2)
// +
// + bb18:
// +     %113 = urem i64 %101, %102
// +     call ccc void _S4sinkFvxiE(i64 %113)
// +     %114 = load i64, #0, align 8
// +     %115 = load i64, #1, align 8
// +     %116 = icmp uge i64 %115, 64
// +     br %116 to bb19 else bb20
// +
// + bb19:
// +     abort at loc("binary-ops.src":17:10) arithmetic(ptr #2)
// +
// + bb20:
// +     %126 = shl i64 %114, %115
// +     %127 = ashr i64 %114, 63
// +     %128 = ashr i64 %126, 63
// +     %129 = icmp ne i64 %127, %128
// +     br %129 to bb21 else bb22
// +
// + bb21:
// +     abort at loc("binary-ops.src":17:10) arithmetic(ptr #2)
// +
// + bb22:
// +     call ccc void _S4sinkFvxiE(i64 %126)
// +     %139 = load i64, #0, align 8
// +     %140 = load i64, #1, align 8
// +     %141 = icmp uge i64 %140, 64
// +     br %141 to bb23 else bb24
// +
// + bb23:
// +     abort at loc("binary-ops.src":18:10) arithmetic(ptr #2)
// +
// + bb24:
// +     %151 = shl i64 %139, %140
// +     call ccc void _S4sinkFvxiE(i64 %151)
// +     ret
// + }
// +
// + proc _S5arithFvxixiE (i64 %0, i64 %1) private ccc {
// +     #0 = 8, align 8
// +     #1 = 8, align 8
// +
// + entry:
// +     store #0, i64 %0, align 8
// +     store #1, i64 %1, align 8
// +     %2 = load i64, #0, align 8
// +     %3 = load i64, #1, align 8
// +     %4 = add i64 %2, %3
// +     call ccc void _S4sinkFvxiE(i64 %4)
// +     %5 = load i64, #0, align 8
// +     %6 = load i64, #1, align 8
// +     %7 = sub i64 %5, %6
// +     call ccc void _S4sinkFvxiE(i64 %7)
// +     %8 = load i64, #0, align 8
// +     %9 = load i64, #1, align 8
// +     %10 = mul i64 %8, %9
// +     call ccc void _S4sinkFvxiE(i64 %10)
// +     %11 = load i64, #0, align 8
// +     %12 = load i64, #1, align 8
// +     %13 = ashr i64 %11, %12
// +     call ccc void _S4sinkFvxiE(i64 %13)
// +     %14 = load i64, #0, align 8
// +     %15 = load i64, #1, align 8
// +     %16 = lshr i64 %14, %15
// +     call ccc void _S4sinkFvxiE(i64 %16)
// +     %17 = load i64, #0, align 8
// +     %18 = load i64, #1, align 8
// +     %19 = and i64 %17, %18
// +     call ccc void _S4sinkFvxiE(i64 %19)
// +     %20 = load i64, #0, align 8
// +     %21 = load i64, #1, align 8
// +     %22 = or i64 %20, %21
// +     call ccc void _S4sinkFvxiE(i64 %22)
// +     %23 = load i64, #0, align 8
// +     %24 = load i64, #1, align 8
// +     %25 = icmp slt i64 %23, %24
// +     call ccc void _S4sinkFvxbE(i1 %25 zeroext)
// +     %26 = load i64, #0, align 8
// +     %27 = load i64, #1, align 8
// +     %28 = icmp sle i64 %26, %27
// +     call ccc void _S4sinkFvxbE(i1 %28 zeroext)
// +     %29 = load i64, #0, align 8
// +     %30 = load i64, #1, align 8
// +     %31 = icmp sgt i64 %29, %30
// +     call ccc void _S4sinkFvxbE(i1 %31 zeroext)
// +     %32 = load i64, #0, align 8
// +     %33 = load i64, #1, align 8
// +     %34 = icmp sge i64 %32, %33
// +     call ccc void _S4sinkFvxbE(i1 %34 zeroext)
// +     %35 = load i64, #0, align 8
// +     %36 = load i64, #1, align 8
// +     %37 = icmp ult i64 %35, %36
// +     call ccc void _S4sinkFvxbE(i1 %37 zeroext)
// +     %38 = load i64, #0, align 8
// +     %39 = load i64, #1, align 8
// +     %40 = icmp ule i64 %38, %39
// +     call ccc void _S4sinkFvxbE(i1 %40 zeroext)
// +     %41 = load i64, #0, align 8
// +     %42 = load i64, #1, align 8
// +     %43 = icmp ugt i64 %41, %42
// +     call ccc void _S4sinkFvxbE(i1 %43 zeroext)
// +     %44 = load i64, #0, align 8
// +     %45 = load i64, #1, align 8
// +     %46 = icmp uge i64 %44, %45
// +     call ccc void _S4sinkFvxbE(i1 %46 zeroext)
// +     %47 = load i64, #0, align 8
// +     %48 = load i64, #1, align 8
// +     %49 = icmp eq i64 %47, %48
// +     call ccc void _S4sinkFvxbE(i1 %49 zeroext)
// +     %50 = load i64, #0, align 8
// +     %51 = load i64, #1, align 8
// +     %52 = icmp ne i64 %50, %51
// +     call ccc void _S4sinkFvxbE(i1 %52 zeroext)
// +     ret
// + }
