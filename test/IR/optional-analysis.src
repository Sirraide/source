// V %srcc --ir --verify %s
program test;

struct s { int x; int y; }

proc g(int) extern;

proc p1 (bool b) {
    int^? pi;
    ^pi = 42; // expected-error: Optional might be nil when accessed here
    ^pi = 42; // expected-error: Optional might be nil when accessed here
    if b {
        ^pi = 42; // expected-error: Optional might be nil when accessed here
    } else {
        ^pi = 42; // expected-error: Optional might be nil when accessed here
    }
}

proc p2 {
    int i;
    int^? pi;
    pi = &i;
    ^pi = 42;
}

proc p3 (bool b) {
    int i;
    int^? pi;
    if b then pi = &i;
    ^pi = 42; // expected-error: Optional might be nil when accessed here
}

proc p4 (bool b) {
    int i;
    int j;
    int^? pi;
    if b then pi = &i;
    else pi = &j;
    ^pi = 42;
}

proc p5 (bool b) {
    int i;
    int^? pi;
    if b then pi = &i;
    else return;
    ^pi = 42;
}

proc p6 (bool b) {
    int i;
    int^? pi;
    pi = &i;
    for x in 1..<10 if b and x == 5 then pi = ();
    ^pi = 42; // expected-error: Optional might be nil when accessed here
}

proc p7 {
    int i;
    int^? pi;
    pi = &i;
    if 1 == 2 then pi = (); // Folded at compile-time and thus recognised as unreachable.
    ^pi = 42;
}

proc p8 {
    int i;
    int^? pi;
    pi = &i;
    {{ g({ pi = (); i; }); }};
    ^pi = 42; // expected-error: Optional might be nil when accessed here
}

proc p9 (bool b) {
    int i;
    int^? pi;
    if b then pi = &i;
    if not b then pi = &i;

    // We’re not quite clever enough for this, but that’s fine (it’d be rather
    // hard to figure out that this is valid).
    ^pi = 42; // expected-error: Optional might be nil when accessed here
}

proc p10 (int^? opt) {
    ^opt = 42; // expected-error: Optional might be nil when accessed here
}

proc p11 {
    int i;
    int^? pi = &i;
    ^pi = 42;
}

proc p12 {
    int i;
    int^? p1 = &i;
    int^? p2 = p1;
    ^p2 = 42;
}

proc p13 {
    int i;
    int^? p1;
    int^? p2 = p1;
    ^p2 = 42; // expected-error: Optional might be nil when accessed here
}

proc p14 {
    s? x;
    x.x = 1; // expected-error: Optional might be nil when accessed here
    x.y = 2; // expected-error: Optional might be nil when accessed here

    if x != nil {
        x.x = 1;
        x.y = 2;
    } else {
        x.x = 1; // expected-error: Optional might be nil when accessed here
        x.y = 2; // expected-error: Optional might be nil when accessed here
    }

    x.x = 1; // expected-error: Optional might be nil when accessed here
    x.y = 2; // expected-error: Optional might be nil when accessed here

    if x == nil {
        x.x = 1; // expected-error: Optional might be nil when accessed here
        x.y = 2; // expected-error: Optional might be nil when accessed here
    } else {
        x.x = 1;
        x.y = 2;
    }

    x.x = 1; // expected-error: Optional might be nil when accessed here
    x.y = 2; // expected-error: Optional might be nil when accessed here

    assert x != nil;
    x.x = 1;
    x.y = 2;

    if x != nil {
        x.x = 1;
        x.y = 2;
    } else {
        x.x = 1;
        x.y = 2;
    }

    if x == nil {
        x.x = 1;
        x.y = 2;
    } else {
        x.x = 1;
        x.y = 2;
    }
}

// Test that we insert the 'engage' op at the edge between
// the condition and destination and not simply in the destination
// block.
proc p15 {
    s? x;
    if x == nil {
        x.x = 1; // expected-error: Optional might be nil when accessed here
        x.y = 2; // expected-error: Optional might be nil when accessed here
    }

    x.x = 1; // expected-error: Optional might be nil when accessed here
    x.y = 2; // expected-error: Optional might be nil when accessed here

    if x != nil {
        x.x = 1;
        x.y = 2;
    }

    x.x = 1; // expected-error: Optional might be nil when accessed here
    x.y = 2; // expected-error: Optional might be nil when accessed here

    assert x == nil;
    x.x = 1; // expected-error: Optional might be nil when accessed here
    x.y = 2; // expected-error: Optional might be nil when accessed here

    assert x != nil;
    x.x = 1;
    x.y = 2;

    // This assert doesn’t actually affect lifetime analysis since we emit the
    // 'engage' into the block that calls the assert handler.
    assert x == nil;
    x.x = 1;
    x.y = 2;
}

proc p16 (int? x) {
    int y = match x {
        5: // expected-error: Optional might be nil when accessed here
            x; // expected-error: Optional might be nil when accessed here
        6: // expected-error: Optional might be nil when accessed here
            x; // expected-error: Optional might be nil when accessed here
        7..=8: // expected-error: Optional might be nil when accessed here
            x; // expected-error: Optional might be nil when accessed here
        nil: 42;
        9: x;
        _: x;
    };
}

proc p17 (int? x) {
    int y = match x {
        nil: 42;
        _ : x;
    };

    int q = x; // expected-error: Optional might be nil when accessed here
    assert x != nil;
    int q2 = x;
}

proc p18(in int^? a, in int^? b) {
    if a != nil and b != nil {
        ^a = 3;
        ^b = 3;
    } else {
        ^a = 3; // expected-error: Optional might be nil when accessed here
        ^b = 3; // expected-error: Optional might be nil when accessed here
    }
}

proc p19(in int^? a, in int^? b) {
    if a == nil or b == nil {
        ^a = 3; // expected-error: Optional might be nil when accessed here
        ^b = 3; // expected-error: Optional might be nil when accessed here
    } else {
        ^a = 3;
        ^b = 3;
    }
}