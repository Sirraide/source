// V %srcc --sema --verify %s
program test;

var x = match true {
    true: 1;
    false: 2;
};

var y = match false {
    true: 3;
    false: 4;
};

bool b;

match true {}; // expected-error ('match' is not exhaustive) expected-note (Possible values 'true' and 'false' are not handled)

match true { // expected-error ('match' is not exhaustive) expected-note (Possible values 'true' and 'false' are not handled)
    b: 1;
}

match true { // expected-error ('match' is not exhaustive) expected-note (Possible value 'false' is not handled)
    true: 1;
};

match true { // expected-error ('match' is not exhaustive) expected-note (Possible value 'true' is not handled)
    false: 1;
};

match true {
    true: 1; // expected-note: Because it is subsumed by this preceding pattern
    true: 2; // expected-warning: Pattern will never be matched
    false: 3;
};

match true {
    false: 2; // expected-note: Because it is subsumed by this preceding pattern
    false: 3; // expected-warning: Pattern will never be matched
    true: 1;
};

match true {
    true: 1;
    false: 1; // expected-note: Because this pattern already makes the 'match' fully exhaustive
    true: 1;  // expected-warning: This and any following patterns will never be matched
};

match false {
    false: 1;
    true: 1;  // expected-note: Because this pattern already makes the 'match' fully exhaustive
    false: 1; // expected-warning: This and any following patterns will never be matched
};
match false {
    false: 1;
    true: 1;  // expected-note: Because this pattern already makes the 'match' fully exhaustive
    false: 1; // expected-warning: This and any following patterns will never be matched
    false: 1;
    true: 1;
};

match true {
    false: 1;
    true: 2; // expected-note: Because this pattern already makes the 'match' fully exhaustive
    b: 3;    // expected-warning: This and any following patterns will never be matched
}

match true {
    b: 3;
    b: 3;
    b: 3;
    b: 3;
    b: 3;
    b: 3;
    true: 1;
    false: 3;
}

match true {
    2: true; // expected-error: Cannot match 'int' against 'bool'
    {}: true; // expected-error: Cannot match 'void' against 'bool'
}

match true {
    1 == 1: 4;
    1 != 1: 3;
}

match true { // expected-error ('match' is not exhaustive) expected-note (Possible value 'false' is not handled)
    1 == 1: 4; // expected-note: Because it is subsumed by this preceding pattern
    2 == 2: 3; // expected-warning: Pattern will never be matched
}

int z1 = match true { // expected-error: Cannot convert expression of type 'void' to 'int'
    true: 1;
    false: "";
};

int^ z2 = &match true {
    true: x;
    false: y;
};

int^ z3 = &match true { // expected-error: Cannot take address of non-lvalue
    true: x;
    false: 1;
};

int^ z4 = &match true {
    b: x;
    b: y;
    true: x;
    false: y;
};

int^ z5 = &match true { // expected-error: Cannot take address of non-lvalue
    b: x;
    b: 1;
    true: x;
    false: y;
};

int^ z6 = &match true {
    true: x; // expected-note: Because it is subsumed by this preceding pattern
    true: 1; // expected-warning: Pattern will never be matched
    false: y;
};

int^ z6 = &match true {
    true: x;
    false: y; // expected-note: Because this pattern already makes the 'match' fully exhaustive
    true: 1; // expected-warning: This and any following patterns will never be matched
};

match true { _: 1; }
match true {
    _: 1; // expected-note: Because this pattern already makes the 'match' fully exhaustive
    true: 2; // expected-warning: This and any following patterns will never be matched
}

match true {
    _: 1; // expected-note: Because this pattern already makes the 'match' fully exhaustive
    _: 2; // expected-warning: This and any following patterns will never be matched
}

int x = match 1 {
    1: 2;
    _: 3;
};

int x = match 1 {
    1: 2;
    _: 3; // expected-note: Because this pattern already makes the 'match' fully exhaustive
    1: 2; // expected-warning: This and any following patterns will never be matched
};

match 1 -> 2 { // expected-error: Expected type
    _: 3;
}

i8 y = match 1 {
    1: 2;
    _: 4;
};

i8 y = match 1 -> i8 { // expected-error ('match' is not exhaustive) expected-note (Possible value ranges not handled)
    1: 2;
};

match -> i8 { // expected-error: A 'match' with a fixed result type must have a wildcard arm
    true: 2;
};

// These are explicitly allowed to not be exhaustive.
match -> void { };
match -> var { };

i8 y = match 1 -> i8 {
    1: 2;
    _: 4;
};

i8 y = match 1 -> i8 {
    1: ""; // expected-error: Cannot convert expression of type 'i8[]' to 'i8'
    _: "".data; // expected-error (Cannot convert expression of type 'i8^' to 'i8') expected-note (Because this pattern already makes the 'match' fully exhaustive)

    // No error here since we donâ€™t attempt to convert unreachable patterns.
    1: 2; // expected-warning: This and any following patterns will never be matched
};

int lvalue;

// The first two are non-exhaustive, so they yield 'void'!
(match { true: lvalue; false: lvalue; }) = 3; // expected-error: Invalid target for assignment
(match -> int { true: lvalue; false: lvalue; }) = 3; // expected-error: A 'match' with a fixed result type must have a wildcard arm
(match { true: lvalue; _: lvalue; }) = 3;
(match -> int { true: lvalue; _: lvalue; }) = 3;