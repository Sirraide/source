// V %srcc --sema --verify %s
program test;

proc good -> int {
    #inject(quote { int }) x = #inject(quote { 22 });
    #inject(quote { i64 }) y = #inject(quote { 20 as i64 });
    return #inject(quote { x }) + #inject(quote { y }) as int;
}

#assert good() == 42;

proc bad {
    #inject(1); // expected-error: Cannot inject value of type 'int'
    #inject(int); // expected-error: Cannot inject value of type 'type'
    #inject(""); // expected-error: Cannot inject value of type 'i8[]'
}

proc add (tree a) = quote {
    x + $(a) * 2 + y;
};

proc do_add -> int {
    int arg = 15;
    int x = 5;
    int y = 5;
    return 1 + #add(arg) + 1;
}

#assert do_add() == 42;

proc return_if (tree cond, tree value) = quote {
    if $(cond) then return $(value);
}

proc call (bool b) -> int {
    #return_if(b, 42);
    return 7;
}

#assert call(true) == 42;
#assert call(false) == 7;

proc when (tree cond, tree then_, tree else_) = quote(if $(cond) then $(then_) else $(else_));
proc eq(int a, int b) = #when(a == b, 3, 4);
proc not_reached() -> int = __srcc_unreachable();

#assert eq(1, 1) == 3;
#assert eq(1, 2345245) == 4;
#assert #when(1 == 1, 5, not_reached()) == 5;
#assert #when(1 == 2, not_reached(), 6) == 6;

var i = #inject(quote { // expected-error: An '#inject' in this context must result in exactly 1 statement; got 2
    int x;
    int y;
});

var i = #inject(quote {}); // expected-error: An '#inject' in this context must result in exactly 1 statement; got 0
var i = #inject(quote { 42; });
